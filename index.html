<!DOCTYPE html>
<html>
<head>
<title>SVG Door Visualizer</title>
<style>
  /* --- Copied CSS from index.html --- */
  body { margin: 0; background-color: #f0f0f0; font-family: sans-serif; font-size: 16px; /* Base font size */ }
  /* svg { border: 1px solid black; display: block; } */ /* Style SVG directly if needed */
   svg { border: 1px solid black; display: block; user-select: none; /* Prevent text selection during drag */ }
  .controls { padding: 0 10px 10px 10px; /* Padding adjusted */ background-color: transparent; border: none; }
  .controls legend {
      font-weight: 600; /* Bolder */
      margin-bottom: 20px; /* More space */
      font-size: 1.4rem; /* Significantly larger */
      color: #111; /* Darker */
      border-bottom: 2px solid #aaa; /* Thicker separator */
      padding-bottom: 8px;
      width: 100%;
      box-sizing: border-box;
  }
  .controls div { margin-bottom: 20px; /* More vertical space */ }
  .controls label {
      display: block;
      margin-bottom: 6px;
      text-align: left;
      font-size: 1.15rem; /* Larger labels */
      color: #444; /* Slightly darker */
      font-weight: 500;
  }
  .controls .input-row { display: block; }
  .controls input {
      width: 100%;
      box-sizing: border-box;
      padding: 15px 12px; /* Significantly taller */
      font-size: 1.2rem; /* Larger input font */
      border: 1px solid #999; /* Clearer border */
      border-radius: 5px;
      background-color: #fff; /* White background */
  }

  /* Settings Container - Mobile First (Hidden) */
  .settings-container {
    position: fixed;
    top: 0;
    left: 0;
    height: 100%; /* Use 100% */
    width: 90%; /* Wider panel */
    max-width: 400px; /* Increase max width */
    background-color: rgba(240, 240, 240, 0.98); /* More opaque */
    border-right: 1px solid #bbb;
    padding: 20px; /* More padding */
    box-sizing: border-box;
    overflow-y: auto;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 25px; /* More space between fieldsets */
    transform: translateX(-105%);
    transition: transform 0.3s ease-in-out;
  }

  .settings-container.active {
    transform: translateX(0);
  }

  /* Hamburger Button */
  #hamburger-btn {
      position: fixed;
      top: 15px; /* Adjusted position */
      left: 15px;
      z-index: 1001;
      font-size: 28px; /* Larger icon */
      padding: 8px 12px;
      background-color: #e0e0e0;
      border: 1px solid #adadad;
      cursor: pointer;
      border-radius: 5px;
      line-height: 1;
  }

  /* Close Button (inside settings) */
  #close-settings-btn {
      position: absolute;
      top: 10px; /* Adjusted position */
      right: 15px;
      font-size: 28px; /* Larger icon */
      background: none;
      border: none;
      cursor: pointer;
      padding: 5px;
      line-height: 1;
      color: #555;
  }

  /* --- SVG Specific Styles --- */
  .door-group {
      cursor: grab;
  }
  .door-group.grabbing {
      cursor: grabbing;
  }

  /* Print Button Hover Effect */
  #printPagesBtn:hover {
      background-color: #45a049 !important;
  }


</style>

</head>
<body>

<div>
  <svg id="doorSvg" width="1" height="1">
      <defs>
          <!-- Clip Paths for Door Inner Areas -->
          <clipPath id="left-door-clip">
              <rect id="left-clip-rect" x="0" y="0" width="100" height="100" />
          </clipPath>
          <clipPath id="right-door-clip">
              <rect id="right-clip-rect" x="0" y="0" width="100" height="100" />
          </clipPath>
      </defs>

      <!-- A4 Page Tiles (Background Layer) -->
      <g id="a4-tiles-group">
          <!-- A4 rectangles will be generated here -->
      </g>

      <!-- Left Door Group -->
      <g id="left-door-group" class="door-group" transform="translate(0, 0)">
          <!-- Frame -->
          <rect id="left-door-frame" x="0" y="0" width="100" height="100" fill="none" stroke="black" stroke-width="1" />
          <!-- Sectors (Clipped) -->
          <g id="left-sectors-group" clip-path="url(#left-door-clip)">
              <!-- Sector paths will be generated here -->
          </g>
          <!-- Vanishing Point -->
          <circle id="left-vp" cx="50" cy="110" r="1" fill="blue" />
      </g>

      <!-- Right Door Group -->
      <g id="right-door-group" class="door-group" transform="translate(150, 0)">
           <!-- Frame -->
          <rect id="right-door-frame" x="0" y="0" width="100" height="100" fill="none" stroke="black" stroke-width="1" />
          <!-- Sectors (Clipped) -->
          <g id="right-sectors-group" clip-path="url(#right-door-clip)">
              <!-- Sector paths will be generated here -->
          </g>
          <!-- Vanishing Point -->
          <circle id="right-vp" cx="50" cy="110" r="1" fill="blue" />
      </g>
  </svg>
</div>

<button id="hamburger-btn">‚ò∞</button>

<div class="settings-container" id="settings-panel">
    <button id="close-settings-btn">√ó</button>
    <!-- Copied Fieldsets from index.html -->
    <fieldset class="controls">
      <legend>Global Settings</legend>
      <div>
        <label for="innerWidthInput">Inner Width (cm):</label>
        <div class="input-row">
            <input type="number" id="innerWidthInput" value="49" min="10" max="100" step="1">
        </div>
      </div>
      <div>
        <label for="innerHeightInput">Inner Height (cm):</label>
        <div class="input-row">
            <input type="number" id="innerHeightInput" value="27" min="10" max="60" step="1">
        </div>
      </div>

      <!-- Display Calculated Dimensions -->
      <div>
        <label>Calculated Door Width:</label>
        <div class="input-row">
          <span id="displayDoorWidthCm" style="font-weight: bold; padding: 10px 0; display: inline-block;">-- cm</span>
        </div>
      </div>
       <div>
        <label>Calculated Door Height:</label>
        <div class="input-row">
          <span id="displayDoorHeightCm" style="font-weight: bold; padding: 10px 0; display: inline-block;">-- cm</span>
        </div>
      </div>

      <!-- Door Visibility Controls -->
      <div style="margin-top: 20px; border-top: 1px solid #ddd; padding-top: 20px;">
        <label>Door Visibility:</label>
        <div style="display: flex; gap: 15px; margin-top: 10px;">
          <div style="display: flex; align-items: center;">
            <input type="checkbox" id="leftDoorVisibility" checked style="width: auto; margin-right: 5px;">
            <label for="leftDoorVisibility" style="display: inline; margin: 0;">Left Door</label>
          </div>
          <div style="display: flex; align-items: center;">
            <input type="checkbox" id="rightDoorVisibility" checked style="width: auto; margin-right: 5px;">
            <label for="rightDoorVisibility" style="display: inline; margin: 0;">Right Door</label>
          </div>
        </div>
      </div>

      <!-- A4 Print Preview Controls -->
      <div style="margin-top: 20px; border-top: 1px solid #ddd; padding-top: 20px;">
        <label>Print Preview:</label>
        <div style="display: flex; gap: 15px; margin-top: 10px;">
          <div style="display: flex; align-items: center;">
            <input type="checkbox" id="a4TilesVisibility" checked style="width: auto; margin-right: 5px;">
            <label for="a4TilesVisibility" style="display: inline; margin: 0;">Show A4 Pages</label>
          </div>
        </div>
        <div style="margin-top: 15px;">
          <button id="printPagesBtn" style="width: 100%; padding: 12px; font-size: 1.1rem; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; transition: background-color 0.3s;">
            üñ®Ô∏è Print A4 Pages
          </button>
        </div>
      </div>

    </fieldset>

    <fieldset class="controls">
        <legend>Left Door Settings</legend>
        <div>
            <label for="leftNumSectorsInput">Sectors:</label>
            <div class="input-row">
                <input type="number" id="leftNumSectorsInput" value="17" min="1" max="50" step="1">
            </div>
        </div>
        <div>
            <label for="leftBlackAngleInput">Sector Angle (deg):</label>
            <div class="input-row">
                <input type="number" id="leftBlackAngleInput" value="5" min="0.1" max="45" step="0.1">
            </div>
        </div>
        <div>
            <label for="leftSpaceAngleInput">Space Angle (deg):</label>
            <div class="input-row">
                <input type="number" id="leftSpaceAngleInput" value="3" min="0" max="45" step="0.1">
            </div>
        </div>
        <div>
            <label for="leftVpOffsetInput">Left VP Offset (cm):</label>
            <div class="input-row">
                <input type="number" id="leftVpOffsetInput" value="15" min="0" step="1">
            </div>
        </div>
    </fieldset>

    <fieldset class="controls">
        <legend>Right Door Settings</legend>
        <div>
            <label for="rightNumSectorsInput">Sectors:</label>
            <div class="input-row">
                <input type="number" id="rightNumSectorsInput" value="13" min="1" max="50" step="1">
            </div>
        </div>
        <div>
            <label for="rightBlackAngleInput">Sector Angle (deg):</label>
            <div class="input-row">
                <input type="number" id="rightBlackAngleInput" value="6" min="0.1" max="45" step="0.1">
            </div>
        </div>
        <div>
            <label for="rightSpaceAngleInput">Space Angle (deg):</label>
            <div class="input-row">
                <input type="number" id="rightSpaceAngleInput" value="3" min="0" max="45" step="0.1">
            </div>
        </div>
        <div>
            <label for="rightVpOffsetInput">Right VP Offset (cm):</label>
            <div class="input-row">
                <input type="number" id="rightVpOffsetInput" value="15" min="0" step="1">
            </div>
        </div>
    </fieldset>
</div>

<script>
  // --- Get SVG and Control Elements ---
  const svg = document.getElementById('doorSvg'); // Get SVG element
  // const canvas = document.getElementById('doorCanvas'); // REMOVED
  // const ctx = canvas.getContext('2d'); // REMOVED

  // Get SVG elements by ID (placeholders, update in init/redraw)
  const leftDoorGroup = document.getElementById('left-door-group');
  const leftDoorFrame = document.getElementById('left-door-frame');
  const leftSectorsGroup = document.getElementById('left-sectors-group');
  const leftVp = document.getElementById('left-vp');
  const leftClipRect = document.getElementById('left-clip-rect');

  const rightDoorGroup = document.getElementById('right-door-group');
  const rightDoorFrame = document.getElementById('right-door-frame');
  const rightSectorsGroup = document.getElementById('right-sectors-group');
  const rightVp = document.getElementById('right-vp');
  const rightClipRect = document.getElementById('right-clip-rect');

  // Get A4 tiles group
  const a4TilesGroup = document.getElementById('a4-tiles-group');

  // Get display elements for calculated dimensions
  const displayDoorWidthCm = document.getElementById('displayDoorWidthCm');
  const displayDoorHeightCm = document.getElementById('displayDoorHeightCm');

  // --- Get DOM Elements (Settings Panel) ---
  const settingsPanel = document.getElementById('settings-panel');
  const hamburgerBtn = document.getElementById('hamburger-btn');
  const closeSettingsBtn = document.getElementById('close-settings-btn');

  // Global control elements
  const innerWidthInput = document.getElementById('innerWidthInput');
  const innerHeightInput = document.getElementById('innerHeightInput');

  // Get Left Door Setting control elements
  const leftNumSectorsInput = document.getElementById('leftNumSectorsInput');
  const leftBlackAngleInput = document.getElementById('leftBlackAngleInput');
  const leftSpaceAngleInput = document.getElementById('leftSpaceAngleInput');
  const leftVpOffsetInput = document.getElementById('leftVpOffsetInput');
  const leftDoorVisibility = document.getElementById('leftDoorVisibility');

  // Get Right Door Setting control elements
  const rightNumSectorsInput = document.getElementById('rightNumSectorsInput');
  const rightBlackAngleInput = document.getElementById('rightBlackAngleInput');
  const rightSpaceAngleInput = document.getElementById('rightSpaceAngleInput');
  const rightVpOffsetInput = document.getElementById('rightVpOffsetInput');
  const rightDoorVisibility = document.getElementById('rightDoorVisibility');

  // Get A4 tiles visibility control
  const a4TilesVisibility = document.getElementById('a4TilesVisibility');
  
  // Get print button
  const printPagesBtn = document.getElementById('printPagesBtn');

  // --- Door Properties (Constants and Dynamic State) ---
  const scale = 26.872; // Pixels per cm
  const borderWidthCm = 3;
  let borderWidthPx = borderWidthCm * scale; // Will be updated
  const vpRadiusPx = 1;
  const extraHorizontalSpaceCm = 8; // Added for extra horizontal space
  const extraVerticalSpaceCm = 5; // Added for extra vertical space

  // --- A4 Page Dimensions (Landscape) ---
  const a4WidthCm = 29.7; // A4 width in cm (landscape)
  const a4HeightCm = 21.0; // A4 height in cm (landscape)
  const a4WidthPx = a4WidthCm * scale; // A4 width in pixels
  const a4HeightPx = a4HeightCm * scale; // A4 height in pixels
  
  // --- Printer Margins & Overlap ---
  const printerMarginCm = 1.0; // 1cm margin on all sides
  const overlapCm = 1.2; // 1.2cm overlap to ensure no content is lost
  const printableWidthCm = a4WidthCm - (printerMarginCm * 2); // 27.7cm
  const printableHeightCm = a4HeightCm - (printerMarginCm * 2); // 19cm
  const tileStepWidthCm = printableWidthCm - overlapCm; // 26.5cm step between tiles
  const tileStepHeightCm = printableHeightCm - overlapCm; // 17.8cm step between tiles
  const tileStepWidthPx = tileStepWidthCm * scale;
  const tileStepHeightPx = tileStepHeightCm * scale;

  // State variables - Global
  let innerWidthCm = 49;
  let innerHeightCm = 27;

  // Calculated global dimensions (will be updated in updateAndRedraw)
  let doorWidthCm, doorHeightCm, doorWidthPx, doorHeightPx;

  // --- Door States (Position and Settings) ---
  let leftDoorState = {
    x: 0, y: 0, // Position managed by group transform
    numBlackSectors: 19,
    blackSectorDeg: 4,
    spaceSectorDeg: 3,
    vpOffsetYCm: 5,
    blackSectorRad: 0, // Calculated
    spaceSectorRad: 0,  // Calculated
    sectorRadiusCm: 0,  // Calculated dynamically
    sectorRadiusPx: 0,   // Calculated dynamically
    visible: true  // Door visibility state
  };
  let rightDoorState = {
    x: 0, y: 0, // Position managed by group transform
    numBlackSectors: 17,
    blackSectorDeg: 5,
    spaceSectorDeg: 3,
    vpOffsetYCm: 8,
    blackSectorRad: 0, // Calculated
    spaceSectorRad: 0, // Calculated
    sectorRadiusCm: 0,  // Calculated dynamically
    sectorRadiusPx: 0,   // Calculated dynamically
    visible: true  // Door visibility state
  };

  // --- Drag State ---
  let isDragging = false;
  let dragOffsetX = 0;
  let activeDraggedDoor = null; // 'left' or 'right'
  let activeDraggedElement = null; // Reference to the group element being dragged

  // --- SVG Namespace ---
  const svgNS = "http://www.w3.org/2000/svg";

  // --- Update State from Inputs & Redraw ---
  function updateAndRedraw() {
    // Read global values from inputs
    innerWidthCm = parseFloat(innerWidthInput.value);
    innerHeightCm = parseFloat(innerHeightInput.value);

    // Read left door settings values from inputs
    leftDoorState.numBlackSectors = parseInt(leftNumSectorsInput.value);
    leftDoorState.blackSectorDeg = parseFloat(leftBlackAngleInput.value);
    leftDoorState.spaceSectorDeg = parseFloat(leftSpaceAngleInput.value);
    leftDoorState.vpOffsetYCm = parseFloat(leftVpOffsetInput.value);

    // Read right door settings values from inputs
    rightDoorState.numBlackSectors = parseInt(rightNumSectorsInput.value);
    rightDoorState.blackSectorDeg = parseFloat(rightBlackAngleInput.value);
    rightDoorState.spaceSectorDeg = parseFloat(rightSpaceAngleInput.value);
    rightDoorState.vpOffsetYCm = parseFloat(rightVpOffsetInput.value);

    // Recalculate total door dimensions based on inner dimensions + border
    doorWidthCm = innerWidthCm + (borderWidthCm * 2);
    doorHeightCm = innerHeightCm + (borderWidthCm * 2);

    // Recalculate global pixel values
    borderWidthPx = borderWidthCm * scale;
    doorWidthPx = doorWidthCm * scale;
    doorHeightPx = doorHeightCm * scale;
    const extraHorizontalSpacePx = extraHorizontalSpaceCm * scale; // Calculate extra space in pixels

    // Calculate door-specific sector radius based on the new formula
    // Formula: sqrt((innerHeightCm + borderWidthCm + vpOffsetYCm)^2 + (innerWidthCm/2)^2)
    leftDoorState.sectorRadiusCm =2.1+Math.sqrt(
        Math.pow(innerHeightCm + borderWidthCm + leftDoorState.vpOffsetYCm, 2) +
        Math.pow(innerWidthCm / 2, 2)
    );
    leftDoorState.sectorRadiusPx = leftDoorState.sectorRadiusCm * scale;

    rightDoorState.sectorRadiusCm = 2.1+Math.sqrt(
        Math.pow(innerHeightCm + borderWidthCm + rightDoorState.vpOffsetYCm, 2) +
        Math.pow(innerWidthCm / 2, 2)
    );
    rightDoorState.sectorRadiusPx = rightDoorState.sectorRadiusCm * scale;

    // Recalculate door-specific pixel values (radians)
    leftDoorState.blackSectorRad = leftDoorState.blackSectorDeg * Math.PI / 180;
    leftDoorState.spaceSectorRad = leftDoorState.spaceSectorDeg * Math.PI / 180;
    rightDoorState.blackSectorRad = rightDoorState.blackSectorDeg * Math.PI / 180;
    rightDoorState.spaceSectorRad = rightDoorState.spaceSectorDeg * Math.PI / 180;

    // --- Define SVG ViewBox and On-Screen Dimensions ---
    const viewBoxWidthPx = (doorWidthPx * 2) + extraHorizontalSpacePx; // Two doors side-by-side + extra space
    const measurementSpacePx = 50; // Extra space for measurements below doors
    const viewBoxHeightPx = doorHeightPx + (extraVerticalSpaceCm * scale) + measurementSpacePx;    // Height of a single door + extra vertical space + measurement space

    svg.setAttribute('viewBox', `0 0 ${viewBoxWidthPx} ${viewBoxHeightPx}`);

    // --- Dynamic SVG Resizing (for screen) ---
    // Set screen dimensions to match the viewBox for a tight fit
    if (svg.width.baseVal.value !== viewBoxWidthPx || svg.height.baseVal.value !== viewBoxHeightPx) {
        console.log(`Resizing SVG for screen: viewBox="0 0 ${viewBoxWidthPx} ${viewBoxHeightPx}", width=${viewBoxWidthPx}px, height=${viewBoxHeightPx}px`);
        svg.setAttribute('width', viewBoxWidthPx);
        svg.setAttribute('height', viewBoxHeightPx);
    }
    // --- End Screen Resizing ---

    // Update display elements
    if (displayDoorWidthCm) {
        displayDoorWidthCm.textContent = `${doorWidthCm.toFixed(1)} cm`;
    }
    if (displayDoorHeightCm) {
        displayDoorHeightCm.textContent = `${doorHeightCm.toFixed(1)} cm`;
    }

    // Get SVG viewport dimensions (now reflects the new screen size)
    const svgWidth = svg.width.baseVal.value;
    const svgHeight = svg.height.baseVal.value;

    // Recalculate door positions ONLY if not currently dragging
    if (!isDragging) {
      // Position doors initially: left at 0, right next to it, centered vertically
      leftDoorState.x = 2 * scale; // Move 2cm to the right
      rightDoorState.x = doorWidthPx + (3.2 * scale) + (2 * scale); // Start right door after left with 3cm gap, shifted 2cm right
      // Center vertically in the taller viewport
      const centeredY = ((extraVerticalSpaceCm * scale) / 2); // Position doors in middle of extra vertical space
      leftDoorState.y = centeredY;
      rightDoorState.y = centeredY;
    }
    // If dragging, update Y position if height changed
    else {
        // Center vertically in the taller viewport
        const centeredY = ((extraVerticalSpaceCm * scale) / 2); // Position doors in middle of extra vertical space
        leftDoorState.y = centeredY;
        rightDoorState.y = centeredY;
        // Ensure dragged door stays within new bounds after resize (update transform in drag logic)
         if (activeDraggedElement) {
            activeDraggedElement.setAttribute('transform', `translate(${activeDraggedDoor === 'left' ? leftDoorState.x : rightDoorState.x}, ${centeredY})`);
         }
    }

    redrawSVG(); // Redraw SVG with new dimensions/settings/positions
  }


  // --- Draw Single Door and VP (SVG Version) ---
  function drawDoorSVG(doorState, groupElement, frameElement, vpElement, sectorsGroupElement, clipRectElement) {
    const { x, y, numBlackSectors, blackSectorRad, spaceSectorRad, vpOffsetYCm, sectorRadiusPx } = doorState;

    // --- Calculations ---
    const innerWidthPx = doorWidthPx - (borderWidthPx * 2);
    const innerHeightPx = doorHeightPx - (borderWidthPx * 2);
    const vpOffsetYPx = vpOffsetYCm * scale;
    // VP coordinates are relative to the door group's origin (0,0)
    const vpCenterX = doorWidthPx / 2;
    const innerBottomY = doorHeightPx - borderWidthPx / 2; // Bottom of the clipped inner door area
    const vpCenterY = innerBottomY + vpOffsetYPx; // VP positioned relative to inner bottom edge

    // --- Update SVG Elements ---

    // 1. Update Group Position
    // Only update Y here if needed, X is updated on init and during drag
     groupElement.setAttribute('transform', `translate(${x}, ${y})`);

    // 2. Update Frame Rect
    frameElement.setAttribute('width', doorWidthPx);
    frameElement.setAttribute('height', doorHeightPx);
    frameElement.setAttribute('stroke-width', borderWidthPx);
    // x, y are 0, 0 relative to the group

    // 3. Update Clip Path Rect (relative to group)
    clipRectElement.setAttribute('x', borderWidthPx / 2);
    clipRectElement.setAttribute('y', borderWidthPx / 2);
    clipRectElement.setAttribute('width', doorWidthPx - borderWidthPx);
    clipRectElement.setAttribute('height', doorHeightPx - borderWidthPx);

    // 4. Clear existing sectors and measurements
    while (sectorsGroupElement.firstChild) {
        sectorsGroupElement.removeChild(sectorsGroupElement.firstChild);
    }
    
    // Clear any existing measurement elements from the main group
    const elementsToRemove = [];
    for (let child of groupElement.children) {
        // Remove measurement-related elements (text, path brackets, lines)
        if (child.tagName === 'text' || 
            (child.tagName === 'path' && child.getAttribute('stroke') === 'red') ||
            (child.tagName === 'line' && child.getAttribute('stroke') === 'red')) {
            elementsToRemove.push(child);
        }
    }
    elementsToRemove.forEach(element => groupElement.removeChild(element));

    // 5. Draw New Sectors and Calculate Bottom Intersections
    const numSpaces = Math.max(0, numBlackSectors - 1);
    const totalAngleRad = (numBlackSectors * blackSectorRad) + (numSpaces * spaceSectorRad);
    const startAngle = (-Math.PI / 2) - (totalAngleRad / 2); // Center the fan pattern vertically upwards
    const stepRad = blackSectorRad + spaceSectorRad;
    let currentAngle = startAngle;
    
    const sectorWidths = []; // Store sector width measurements

    for (let i = 0; i < numBlackSectors; i++) {
        const endAngle = currentAngle + blackSectorRad;
        if (blackSectorRad > 0) {
            // Calculate arc start/end points relative to VP center
            const startX = vpCenterX + sectorRadiusPx * Math.cos(currentAngle);
            const startY = vpCenterY + sectorRadiusPx * Math.sin(currentAngle);
            const endX = vpCenterX + sectorRadiusPx * Math.cos(endAngle);
            const endY = vpCenterY + sectorRadiusPx * Math.sin(endAngle);

            // Calculate intersection with inner bottom edge (where sectors are actually visible)
            let startIntersectionX = null;
            let endIntersectionX = null;
            
            // For start ray: calculate intersection with inner bottom edge
            if (Math.sin(currentAngle) !== 0) {
                startIntersectionX = vpCenterX + (innerBottomY - vpCenterY) * Math.cos(currentAngle) / Math.sin(currentAngle);
            }
            
            // For end ray: calculate intersection with inner bottom edge
            if (Math.sin(endAngle) !== 0) {
                endIntersectionX = vpCenterX + (innerBottomY - vpCenterY) * Math.cos(endAngle) / Math.sin(endAngle);
            }

            // Calculate sector width if both intersections are valid and within door bounds
            if (startIntersectionX !== null && endIntersectionX !== null && 
                startIntersectionX >= 0 && startIntersectionX <= doorWidthPx &&
                endIntersectionX >= 0 && endIntersectionX <= doorWidthPx) {
                
                const sectorWidthPx = Math.abs(endIntersectionX - startIntersectionX);
                const sectorWidthCm = sectorWidthPx / scale;
                const centerX = (startIntersectionX + endIntersectionX) / 2;
                
                sectorWidths.push({
                    widthCm: sectorWidthCm,
                    centerX: centerX,
                    startX: startIntersectionX,
                    endX: endIntersectionX,
                    sectorIndex: i
                });
                

            }

            // large-arc-flag is 1 if the angle is > 180 degrees (not applicable here)
            const largeArcFlag = blackSectorRad > Math.PI ? 1 : 0;
            // sweep-flag is 1 for positive angle direction (clockwise)
            const sweepFlag = 1;

            // Construct the 'd' attribute string for the path
            const d = [
                `M ${vpCenterX},${vpCenterY}`, // Move to VP center
                `L ${startX},${startY}`,       // Line to arc start
                `A ${sectorRadiusPx},${sectorRadiusPx} 0 ${largeArcFlag} ${sweepFlag} ${endX},${endY}`, // Arc command
                'Z' // Close path (line back to VP center)
            ].join(' ');

            // Create the SVG path element
            const path = document.createElementNS(svgNS, 'path');
            path.setAttribute('d', d);
            path.setAttribute('fill', 'black');
            sectorsGroupElement.appendChild(path);
        }
        currentAngle += stepRad;
    }

    // 6. Add measurements for sector widths
    console.log(`Found ${sectorWidths.length} sectors with width measurements for door`); // Debug
    
    const verticalOffsetStep = 16; // Pixels to offset vertically for odd indices
    
    for (let i = 0; i < sectorWidths.length; i++) {
        const sector = sectorWidths[i];
        const widthCm = sector.widthCm.toFixed(3);
        
        console.log(`Sector ${sector.sectorIndex}: width=${widthCm}cm, center=${sector.centerX}`); // Debug
        
        // Create bracket to show the width span - positioned below inner door area
        const bracketStartY = innerBottomY + 3; // Start bracket 3px below inner door area
        const bracketHeight = 6;
        const bracketEndY = bracketStartY + bracketHeight;
        
        // Alternate vertical position: even indices at baseline, odd indices offset
        const isOdd = i % 2 === 1;
        const baseTextY = bracketEndY + 12; // Position text below bracket with some space
        const textY = baseTextY + (isOdd ? verticalOffsetStep : 0);
        
        // Create measurement text at center of sector - Add to main group element
        const text = document.createElementNS(svgNS, 'text');
        text.setAttribute('x', sector.centerX);
        text.setAttribute('y', textY);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('font-family', 'Arial, sans-serif');
        text.setAttribute('font-size', '12');
        text.setAttribute('fill', 'red');
        text.setAttribute('font-weight', 'bold');
        text.textContent = `${widthCm}cm`;
        groupElement.appendChild(text);
        
        // Create the bracket path
        const bracket = document.createElementNS(svgNS, 'path');
        const d = [
            `M ${sector.startX},${innerBottomY}`, // Start at sector edge on inner bottom
            `L ${sector.startX},${bracketEndY}`, // Down to bracket level
            `L ${sector.endX},${bracketEndY}`, // Across to other sector edge
            `L ${sector.endX},${innerBottomY}` // Up to sector edge on inner bottom
        ].join(' ');
        bracket.setAttribute('d', d);
        bracket.setAttribute('stroke', 'red');
        bracket.setAttribute('stroke-width', '2');
        bracket.setAttribute('fill', 'none');
        groupElement.appendChild(bracket);
        
        // Add connecting line from bracket to text if offset (for odd indices)
        if (isOdd) {
            const connector = document.createElementNS(svgNS, 'line');
            connector.setAttribute('x1', sector.centerX);
            connector.setAttribute('y1', bracketEndY);
            connector.setAttribute('x2', sector.centerX);
            connector.setAttribute('y2', textY - 2);
            connector.setAttribute('stroke', 'red');
            connector.setAttribute('stroke-width', '1');
            connector.setAttribute('stroke-dasharray', '2,2');
            groupElement.appendChild(connector);
        }
    }

    // 7. Update VP Circle (relative to group)
    vpElement.setAttribute('cx', vpCenterX);
    vpElement.setAttribute('cy', vpCenterY);
    vpElement.setAttribute('r', vpRadiusPx); // Radius is constant
  }

  // --- Draw A4 Page Tiles ---
  function drawA4Tiles() {
    // Clear existing A4 tiles
    while (a4TilesGroup.firstChild) {
        a4TilesGroup.removeChild(a4TilesGroup.firstChild);
    }

    // Get current SVG dimensions
    const svgWidth = svg.width.baseVal.value;
    const svgHeight = svg.height.baseVal.value;

    // Calculate how many A4 pages fit with overlap compensation
    const tilesX = Math.ceil(svgWidth / tileStepWidthPx);
    const tilesY = Math.ceil(svgHeight / tileStepHeightPx);

    // Create A4 rectangles with overlap
    for (let row = 0; row < tilesY; row++) {
        for (let col = 0; col < tilesX; col++) {
            const x = col * tileStepWidthPx;
            const y = row * tileStepHeightPx;
            
            // Create A4 rectangle (full size, overlapping)
            const rect = document.createElementNS(svgNS, 'rect');
            rect.setAttribute('x', x);
            rect.setAttribute('y', y);
            rect.setAttribute('width', a4WidthPx);
            rect.setAttribute('height', a4HeightPx);
            rect.setAttribute('fill', 'none');
            rect.setAttribute('stroke', 'green');
            rect.setAttribute('stroke-width', '2');
            rect.setAttribute('stroke-dasharray', '5,5');
            rect.setAttribute('opacity', '0.7');
            
            a4TilesGroup.appendChild(rect);
            
            // Create printable area rectangle (showing the actual printable area)
            const printableRect = document.createElementNS(svgNS, 'rect');
            printableRect.setAttribute('x', x + (printerMarginCm * scale));
            printableRect.setAttribute('y', y + (printerMarginCm * scale));
            printableRect.setAttribute('width', printableWidthCm * scale);
            printableRect.setAttribute('height', printableHeightCm * scale);
            printableRect.setAttribute('fill', 'none');
            printableRect.setAttribute('stroke', 'orange');
            printableRect.setAttribute('stroke-width', '1');
            printableRect.setAttribute('stroke-dasharray', '2,2');
            printableRect.setAttribute('opacity', '0.5');
            
            a4TilesGroup.appendChild(printableRect);
            
            // Add A4 label
            const text = document.createElementNS(svgNS, 'text');
            text.setAttribute('x', x + 10);
            text.setAttribute('y', y + 20);
            text.setAttribute('font-family', 'Arial, sans-serif');
            text.setAttribute('font-size', '14');
            text.setAttribute('fill', 'green');
            text.setAttribute('font-weight', 'bold');
            text.setAttribute('opacity', '0.8');
            text.textContent = `A4 (${col + 1},${row + 1})`;
            
            a4TilesGroup.appendChild(text);
        }
    }
    
    // Draw rulers
    drawRulers();
  }

  // --- Draw Rulers ---
  function drawRulers() {
    // Get current SVG dimensions
    const svgWidth = svg.width.baseVal.value;
    const svgHeight = svg.height.baseVal.value;

    // Horizontal ruler (top)
    const rulerThickness = 20; // pixels
    const rulerGroup = document.createElementNS(svgNS, 'g');
    rulerGroup.setAttribute('id', 'rulers-group');
    
    // Horizontal ruler background
    const hRulerBg = document.createElementNS(svgNS, 'rect');
    hRulerBg.setAttribute('x', 0);
    hRulerBg.setAttribute('y', 0);
    hRulerBg.setAttribute('width', svgWidth);
    hRulerBg.setAttribute('height', rulerThickness);
    hRulerBg.setAttribute('fill', 'rgba(255,255,255,0.9)');
    hRulerBg.setAttribute('stroke', 'black');
    hRulerBg.setAttribute('stroke-width', '1');
    rulerGroup.appendChild(hRulerBg);

    // Horizontal ruler marks and numbers
    const totalCmH = Math.ceil(svgWidth / scale);
    for (let cm = 0; cm <= totalCmH; cm++) {
      const x = cm * scale;
      if (x > svgWidth) break;
      
      // Major tick every cm
      const tick = document.createElementNS(svgNS, 'line');
      tick.setAttribute('x1', x);
      tick.setAttribute('y1', 0);
      tick.setAttribute('x2', x);
      tick.setAttribute('y2', rulerThickness);
      tick.setAttribute('stroke', 'black');
      tick.setAttribute('stroke-width', cm % 5 === 0 ? '2' : '1');
      rulerGroup.appendChild(tick);
      
      // Numbers every 5cm
      if (cm % 5 === 0) {
        const label = document.createElementNS(svgNS, 'text');
        label.setAttribute('x', x + 2);
        label.setAttribute('y', rulerThickness - 3);
        label.setAttribute('font-family', 'Arial, sans-serif');
        label.setAttribute('font-size', '10');
        label.setAttribute('fill', 'black');
        label.textContent = `${cm}cm`;
        rulerGroup.appendChild(label);
      }
    }

    // Vertical ruler (left)
    const vRulerBg = document.createElementNS(svgNS, 'rect');
    vRulerBg.setAttribute('x', 0);
    vRulerBg.setAttribute('y', rulerThickness);
    vRulerBg.setAttribute('width', rulerThickness);
    vRulerBg.setAttribute('height', svgHeight - rulerThickness);
    vRulerBg.setAttribute('fill', 'rgba(255,255,255,0.9)');
    vRulerBg.setAttribute('stroke', 'black');
    vRulerBg.setAttribute('stroke-width', '1');
    rulerGroup.appendChild(vRulerBg);

    // Vertical ruler marks and numbers
    const totalCmV = Math.ceil(svgHeight / scale);
    for (let cm = 0; cm <= totalCmV; cm++) {
      const y = (cm * scale) + rulerThickness;
      if (y > svgHeight) break;
      
      // Major tick every cm
      const tick = document.createElementNS(svgNS, 'line');
      tick.setAttribute('x1', 0);
      tick.setAttribute('y1', y);
      tick.setAttribute('x2', rulerThickness);
      tick.setAttribute('y2', y);
      tick.setAttribute('stroke', 'black');
      tick.setAttribute('stroke-width', cm % 5 === 0 ? '2' : '1');
      rulerGroup.appendChild(tick);
      
      // Numbers every 5cm (rotated)
      if (cm % 5 === 0 && cm > 0) {
        const label = document.createElementNS(svgNS, 'text');
        label.setAttribute('x', rulerThickness - 2);
        label.setAttribute('y', y - 2);
        label.setAttribute('font-family', 'Arial, sans-serif');
        label.setAttribute('font-size', '10');
        label.setAttribute('fill', 'black');
        label.setAttribute('text-anchor', 'end');
        label.textContent = `${cm}cm`;
        rulerGroup.appendChild(label);
      }
    }

    // Add corner square
    const corner = document.createElementNS(svgNS, 'rect');
    corner.setAttribute('x', 0);
    corner.setAttribute('y', 0);
    corner.setAttribute('width', rulerThickness);
    corner.setAttribute('height', rulerThickness);
    corner.setAttribute('fill', 'rgba(200,200,200,0.9)');
    corner.setAttribute('stroke', 'black');
    corner.setAttribute('stroke-width', '1');
    rulerGroup.appendChild(corner);

    // Insert rulers before other content but after A4 tiles
    a4TilesGroup.appendChild(rulerGroup);
  }

  // --- Print A4 Pages ---
  function printA4Pages() {
    // Get current SVG dimensions
    const svgWidth = svg.width.baseVal.value;
    const svgHeight = svg.height.baseVal.value;

    // Calculate how many A4 pages fit with overlap
    const tilesX = Math.ceil(svgWidth / tileStepWidthPx);
    const tilesY = Math.ceil(svgHeight / tileStepHeightPx);

    let pagesWithContent = [];

    // Check each A4 tile for content (using overlapping positions)
    for (let row = 0; row < tilesY; row++) {
      for (let col = 0; col < tilesX; col++) {
        const tileX = col * tileStepWidthPx;
        const tileY = row * tileStepHeightPx;
        
        // Check if this tile has any door content
        if (hasContentInTile(tileX, tileY, a4WidthPx, a4HeightPx)) {
          pagesWithContent.push({
            col: col,
            row: row,
            x: tileX,
            y: tileY,
            pageNum: pagesWithContent.length + 1
          });
        }
      }
    }

    if (pagesWithContent.length === 0) {
      alert('No content found in any A4 pages to print.');
      return;
    }

    // Create single page with all A4 tiles arranged vertically
    createPrintPage(pagesWithContent);
  }

  // Check if a tile has any door content
  function hasContentInTile(tileX, tileY, tileWidth, tileHeight) {
    const tileRight = tileX + tileWidth;
    const tileBottom = tileY + tileHeight;

    // Check left door if visible
    if (leftDoorState.visible) {
      const leftDoorRight = leftDoorState.x + doorWidthPx;
      const leftDoorBottom = leftDoorState.y + doorHeightPx;
      
      // Check if left door overlaps with this tile
      if (leftDoorState.x < tileRight && leftDoorRight > tileX &&
          leftDoorState.y < tileBottom && leftDoorBottom > tileY) {
        return true;
      }
    }

    // Check right door if visible
    if (rightDoorState.visible) {
      const rightDoorRight = rightDoorState.x + doorWidthPx;
      const rightDoorBottom = rightDoorState.y + doorHeightPx;
      
      // Check if right door overlaps with this tile
      if (rightDoorState.x < tileRight && rightDoorRight > tileX &&
          rightDoorState.y < tileBottom && rightDoorBottom > tileY) {
        return true;
      }
    }

    return false;
  }

  // Create a single print page with all A4 tiles arranged vertically
  function createPrintPage(pages) {
    const printWindow = window.open('', '_blank', 'width=800,height=600');
    
    if (!printWindow) {
      alert('Popup blocked! Please allow popups for this site and try again.');
      return;
    }

    // Generate HTML for all pages arranged vertically
    let allPagesHTML = '';
    
    pages.forEach((page, index) => {
      allPagesHTML += `
        <div class="a4-page" style="page-break-after: always; margin-bottom: 2cm;">
          <div class="page-index">X:${page.col + 1}, Y:${page.row + 1}</div>
          <div class="page-info">A4 Page ${page.pageNum} (${page.col + 1},${page.row + 1})</div>
          <div class="svg-container">
            ${generateA4SVG(page.x, page.y)}
          </div>
        </div>
      `;
    });

          const printHTML = `
        <!DOCTYPE html>
        <html>
        <head>
          <title>Door A4 Pages (Landscape)</title>
          <style>
            @page {
              margin: 1cm;
              size: A4 landscape;
            }
            body {
              margin: 0;
              padding: 0;
              background: white;
              font-family: Arial, sans-serif;
            }
            .a4-page {
              width: 29.7cm;
              height: 21cm;
              position: relative;
              background: white;
              border: 1px solid #ddd;
              margin-bottom: 1cm;
            }
            .page-index {
              position: absolute;
              top: 5px;
              left: 5px;
              font-size: 14px;
              color: green;
              font-weight: bold;
              z-index: 1000;
              background: rgba(255,255,255,0.9);
              padding: 4px 8px;
              border-radius: 3px;
              border: 1px solid green;
            }
            .page-info {
              position: absolute;
              top: 5px;
              right: 5px;
              font-size: 10px;
              color: #666;
              z-index: 1000;
              background: rgba(255,255,255,0.8);
              padding: 2px 4px;
              border-radius: 2px;
            }
            .svg-container {
              width: 100%;
              height: 100%;
              overflow: hidden;
            }
            @media print {
              .a4-page {
                border: none;
                margin-bottom: 0;
              }
            }
          </style>
        </head>
      <body>
        <h1 style="text-align: center; margin: 20px 0;">Door A4 Pages for Printing (Landscape)</h1>
        <div style="text-align: center; margin-bottom: 30px; background: #f0f0f0; padding: 15px; border-radius: 5px;">
          <p><strong>Found ${pages.length} page(s) with content</strong></p>
          <p style="margin: 10px 0; font-size: 14px;">
            üìê <strong>Printer Setup:</strong> 1cm margins compensated with 1.2cm overlap between pages<br/>
            üìè <strong>Rulers:</strong> Use the cm rulers on each page for precise alignment<br/>
            ‚úÇÔ∏è <strong>Assembly:</strong> Overlap pages by 1.2cm and align using ruler marks<br/>
            üî¥ <strong>Red dashed line:</strong> Shows actual printable area (considering 1cm printer margins)
          </p>
          <p style="margin-top: 15px;"><em>Use browser's print button to print all pages</em></p>
        </div>
        ${allPagesHTML}
      </body>
      </html>
    `;

    printWindow.document.write(printHTML);
    printWindow.document.close();
  }

  // Generate SVG content for a specific A4 tile
  function generateA4SVG(tileX, tileY) {
    // Create SVG with A4 viewBox (showing only the content within this tile)
    let svgContent = `<svg width="29.7cm" height="21cm" viewBox="${tileX} ${tileY} ${a4WidthPx} ${a4HeightPx}" xmlns="http://www.w3.org/2000/svg">`;
    
    // Add styles
    svgContent += `
      <style>
        .door-group { cursor: default; }
        text { font-family: Arial, sans-serif; }
        .ruler-text { font-family: Arial, sans-serif; font-size: 8px; }
      </style>
    `;

    // Add defs if needed (clip paths)
    svgContent += `<defs>
      <clipPath id="left-door-clip-print-${tileX}-${tileY}">
        <rect x="${leftDoorState.x + borderWidthPx / 2}" y="${leftDoorState.y + borderWidthPx / 2}" 
              width="${doorWidthPx - borderWidthPx}" height="${doorHeightPx - borderWidthPx}" />
      </clipPath>
      <clipPath id="right-door-clip-print-${tileX}-${tileY}">
        <rect x="${rightDoorState.x + borderWidthPx / 2}" y="${rightDoorState.y + borderWidthPx / 2}" 
              width="${doorWidthPx - borderWidthPx}" height="${doorHeightPx - borderWidthPx}" />
      </clipPath>
    </defs>`;

    // Add rulers for this tile
    svgContent += generateRulersForPrint(tileX, tileY);

    // Add printable area guide
    const printableX = tileX + (printerMarginCm * scale);
    const printableY = tileY + (printerMarginCm * scale);
    svgContent += `<rect x="${printableX}" y="${printableY}" 
                    width="${printableWidthCm * scale}" height="${printableHeightCm * scale}" 
                    fill="none" stroke="red" stroke-width="1" stroke-dasharray="3,3" opacity="0.3" />`;

    // Check if left door is in this tile and add it
    if (leftDoorState.visible && doorIntersectsTile(leftDoorState, tileX, tileY)) {
      svgContent += generateDoorSVGForPrint(leftDoorState, 'left', `left-door-clip-print-${tileX}-${tileY}`);
    }

    // Check if right door is in this tile and add it
    if (rightDoorState.visible && doorIntersectsTile(rightDoorState, tileX, tileY)) {
      svgContent += generateDoorSVGForPrint(rightDoorState, 'right', `right-door-clip-print-${tileX}-${tileY}`);
    }

    svgContent += '</svg>';
    return svgContent;
  }

  // Generate rulers for print
  function generateRulersForPrint(tileX, tileY) {
    let rulerContent = '';
    const rulerThickness = 15;
    
    // Horizontal ruler (top edge of tile)
    rulerContent += `<rect x="${tileX}" y="${tileY}" width="${a4WidthPx}" height="${rulerThickness}" 
                      fill="rgba(255,255,255,0.9)" stroke="black" stroke-width="0.5" />`;
    
    // Horizontal ruler marks
    const startCmH = Math.floor(tileX / scale);
    const endCmH = Math.ceil((tileX + a4WidthPx) / scale);
    for (let cm = startCmH; cm <= endCmH; cm++) {
      const x = cm * scale;
      if (x >= tileX && x <= tileX + a4WidthPx) {
        rulerContent += `<line x1="${x}" y1="${tileY}" x2="${x}" y2="${tileY + rulerThickness}" 
                          stroke="black" stroke-width="${cm % 5 === 0 ? '1' : '0.5'}" />`;
        if (cm % 5 === 0) {
          rulerContent += `<text x="${x + 2}" y="${tileY + rulerThickness - 2}" class="ruler-text" fill="black">${cm}cm</text>`;
        }
      }
    }
    
    // Vertical ruler (left edge of tile)
    rulerContent += `<rect x="${tileX}" y="${tileY + rulerThickness}" width="${rulerThickness}" height="${a4HeightPx - rulerThickness}" 
                      fill="rgba(255,255,255,0.9)" stroke="black" stroke-width="0.5" />`;
    
    // Vertical ruler marks
    const startCmV = Math.floor(tileY / scale);
    const endCmV = Math.ceil((tileY + a4HeightPx) / scale);
    for (let cm = startCmV; cm <= endCmV; cm++) {
      const y = cm * scale;
      if (y >= tileY + rulerThickness && y <= tileY + a4HeightPx) {
        rulerContent += `<line x1="${tileX}" y1="${y}" x2="${tileX + rulerThickness}" y2="${y}" 
                          stroke="black" stroke-width="${cm % 5 === 0 ? '1' : '0.5'}" />`;
        if (cm % 5 === 0 && cm > 0) {
          rulerContent += `<text x="${tileX + rulerThickness - 2}" y="${y - 1}" class="ruler-text" fill="black" text-anchor="end">${cm}cm</text>`;
        }
      }
    }
    
    // Corner square
    rulerContent += `<rect x="${tileX}" y="${tileY}" width="${rulerThickness}" height="${rulerThickness}" 
                      fill="rgba(200,200,200,0.9)" stroke="black" stroke-width="0.5" />`;
    
    return rulerContent;
  }

  // Check if door intersects with the tile
  function doorIntersectsTile(doorState, tileX, tileY) {
    const tileRight = tileX + a4WidthPx;
    const tileBottom = tileY + a4HeightPx;
    const doorRight = doorState.x + doorWidthPx;
    const doorBottom = doorState.y + doorHeightPx;
    
    return doorState.x < tileRight && doorRight > tileX &&
           doorState.y < tileBottom && doorBottom > tileY;
  }

  // Generate SVG content for a door (for printing)
  function generateDoorSVGForPrint(doorState, doorSide, clipId) {
    const { x, y, numBlackSectors, blackSectorRad, spaceSectorRad, vpOffsetYCm, sectorRadiusPx } = doorState;
    
    let svgContent = `<g class="door-group">`;
    
    // Add door frame
    svgContent += `<rect x="${x}" y="${y}" width="${doorWidthPx}" height="${doorHeightPx}" 
                    fill="none" stroke="black" stroke-width="${borderWidthPx}" />`;
    
    // Add sectors group with clipping
    svgContent += `<g clip-path="url(#${clipId})">`;
    
    // Calculate VP position
    const vpOffsetYPx = vpOffsetYCm * scale;
    const vpCenterX = x + doorWidthPx / 2;
    const innerBottomY = y + doorHeightPx - borderWidthPx / 2;
    const vpCenterY = innerBottomY + vpOffsetYPx;
    
    // Generate sectors
    const numSpaces = Math.max(0, numBlackSectors - 1);
    const totalAngleRad = (numBlackSectors * blackSectorRad) + (numSpaces * spaceSectorRad);
    const startAngle = (-Math.PI / 2) - (totalAngleRad / 2);
    const stepRad = blackSectorRad + spaceSectorRad;
    let currentAngle = startAngle;
    
    const sectorWidths = [];
    
    for (let i = 0; i < numBlackSectors; i++) {
      const endAngle = currentAngle + blackSectorRad;
      if (blackSectorRad > 0) {
        const startX = vpCenterX + sectorRadiusPx * Math.cos(currentAngle);
        const startY = vpCenterY + sectorRadiusPx * Math.sin(currentAngle);
        const endX = vpCenterX + sectorRadiusPx * Math.cos(endAngle);
        const endY = vpCenterY + sectorRadiusPx * Math.sin(endAngle);
        
        // Calculate sector width for measurements
        let startIntersectionX = null;
        let endIntersectionX = null;
        
        if (Math.sin(currentAngle) !== 0) {
          startIntersectionX = vpCenterX + (innerBottomY - vpCenterY) * Math.cos(currentAngle) / Math.sin(currentAngle);
        }
        
        if (Math.sin(endAngle) !== 0) {
          endIntersectionX = vpCenterX + (innerBottomY - vpCenterY) * Math.cos(endAngle) / Math.sin(endAngle);
        }
        
        if (startIntersectionX !== null && endIntersectionX !== null && 
            startIntersectionX >= x && startIntersectionX <= x + doorWidthPx &&
            endIntersectionX >= x && endIntersectionX <= x + doorWidthPx) {
          
          const sectorWidthPx = Math.abs(endIntersectionX - startIntersectionX);
          const sectorWidthCm = sectorWidthPx / scale;
          const centerX = (startIntersectionX + endIntersectionX) / 2;
          
          sectorWidths.push({
            widthCm: sectorWidthCm,
            centerX: centerX,
            startX: startIntersectionX,
            endX: endIntersectionX,
            sectorIndex: i
          });
        }
        
        const largeArcFlag = blackSectorRad > Math.PI ? 1 : 0;
        const sweepFlag = 1;
        
        const d = [
          `M ${vpCenterX},${vpCenterY}`,
          `L ${startX},${startY}`,
          `A ${sectorRadiusPx},${sectorRadiusPx} 0 ${largeArcFlag} ${sweepFlag} ${endX},${endY}`,
          'Z'
        ].join(' ');
        
        svgContent += `<path d="${d}" fill="black" />`;
      }
      currentAngle += stepRad;
    }
    
    svgContent += '</g>'; // Close sectors group
    
    // Add measurements
    const verticalOffsetStep = 16;
    
    for (let i = 0; i < sectorWidths.length; i++) {
      const sector = sectorWidths[i];
      const widthCm = sector.widthCm.toFixed(3);
      
      const bracketStartY = innerBottomY + 3;
      const bracketHeight = 6;
      const bracketEndY = bracketStartY + bracketHeight;
      
      const isOdd = i % 2 === 1;
      const baseTextY = bracketEndY + 12;
      const textY = baseTextY + (isOdd ? verticalOffsetStep : 0);
      
      // Add measurement text
      svgContent += `<text x="${sector.centerX}" y="${textY}" text-anchor="middle" 
                      font-family="Arial, sans-serif" font-size="12" fill="red" font-weight="bold">
                      ${widthCm}cm</text>`;
      
      // Add bracket
      const bracketPath = [
        `M ${sector.startX},${innerBottomY}`,
        `L ${sector.startX},${bracketEndY}`,
        `L ${sector.endX},${bracketEndY}`,
        `L ${sector.endX},${innerBottomY}`
      ].join(' ');
      
      svgContent += `<path d="${bracketPath}" stroke="red" stroke-width="2" fill="none" />`;
      
      // Add connecting line for odd indices
      if (isOdd) {
        svgContent += `<line x1="${sector.centerX}" y1="${bracketEndY}" 
                        x2="${sector.centerX}" y2="${textY - 2}" 
                        stroke="red" stroke-width="1" stroke-dasharray="2,2" />`;
      }
    }
    
    // Add vanishing point
    svgContent += `<circle cx="${vpCenterX}" cy="${vpCenterY}" r="1" fill="blue" />`;
    
    svgContent += '</g>'; // Close door group
    
    return svgContent;
  }


  // --- Redraw SVG ---
  function redrawSVG() {
    // Draw A4 page tiles first (background layer) if enabled
    if (a4TilesVisibility.checked) {
      drawA4Tiles();
    } else {
      // Clear A4 tiles and rulers if disabled
      while (a4TilesGroup.firstChild) {
        a4TilesGroup.removeChild(a4TilesGroup.firstChild);
      }
    }
    
    // No need to clear SVG like canvas, just update elements
    drawDoorSVG(leftDoorState, leftDoorGroup, leftDoorFrame, leftVp, leftSectorsGroup, leftClipRect);
    drawDoorSVG(rightDoorState, rightDoorGroup, rightDoorFrame, rightVp, rightSectorsGroup, rightClipRect);
    
    // Update visibility of doors based on door state
    leftDoorGroup.style.display = leftDoorState.visible ? 'block' : 'none';
    rightDoorGroup.style.display = rightDoorState.visible ? 'block' : 'none';
  }

  // --- Helper to get SVG coordinates from mouse/touch event ---
  function getSVGCoordinates(event) {
      const pt = svg.createSVGPoint();
      if (event.touches && event.touches.length > 0) {
          // Touch event
          pt.x = event.touches[0].clientX;
          pt.y = event.touches[0].clientY;
      } else {
          // Mouse event
          pt.x = event.clientX;
          pt.y = event.clientY;
      }
      // Transform screen coordinates to SVG coordinates
      const svgPoint = pt.matrixTransform(svg.getScreenCTM().inverse());
      return { x: svgPoint.x, y: svgPoint.y };
  }


  // --- Event Handlers (Common Logic for SVG Drag) ---
  let startDragSVGX, startDragSVGY; // Use SVG coordinates
  let initialTranslateX; // Store initial transform x of the dragged group
  const keyMoveStep = 5; // Pixels to move door with each keypress

 function handleDragStartSVG(event) {
    const coords = getSVGCoordinates(event);
    startDragSVGX = coords.x;
    startDragSVGY = coords.y;

    let targetGroup = null;
    let doorType = null;

    // Determine which group was clicked (event.target might be child element)
    if (leftDoorGroup.contains(event.target)) {
        targetGroup = leftDoorGroup;
        doorType = 'left';
    } else if (rightDoorGroup.contains(event.target)) {
        targetGroup = rightDoorGroup;
        doorType = 'right';
    }

    if (targetGroup) {
        isDragging = true;
        activeDraggedDoor = doorType;
        activeDraggedElement = targetGroup; // Store the element itself

        // Get the current translation from the transform attribute
        const transform = targetGroup.transform.baseVal;
        initialTranslateX = transform.numberOfItems > 0 ? transform.getItem(0).matrix.e : 0;

        dragOffsetX = startDragSVGX - initialTranslateX; // Offset relative to element's origin

        targetGroup.classList.add('grabbing'); // Add grabbing cursor class
        return true; // Indicate drag started
    }
    return false; // Drag did not start on a door
 }


 function handleDragMoveSVG(event) {
     if (!isDragging || !activeDraggedElement) return;

     const coords = getSVGCoordinates(event);
     const currentSVGX = coords.x;

     let newTranslateX = currentSVGX - dragOffsetX;
     const svgWidth = svg.width.baseVal.value;

     // Apply constraints
     newTranslateX = Math.max(0, newTranslateX); // Prevent dragging past left edge
     newTranslateX = Math.min(newTranslateX, svgWidth - doorWidthPx - scale); // Prevent dragging past right edge (1cm buffer)

     // Update the transform attribute directly
     // Keep the existing Y translation (which should be up-to-date from updateAndRedraw)
     const currentY = activeDraggedDoor === 'left' ? leftDoorState.y : rightDoorState.y;
     activeDraggedElement.setAttribute('transform', `translate(${newTranslateX}, ${currentY})`);

     // Update the corresponding door state's x variable
     if (activeDraggedDoor === 'left') {
         leftDoorState.x = newTranslateX;
     } else {
         rightDoorState.x = newTranslateX;
     }
     // No redraw needed here as transform handles the visual update
 }


  function handleDragEndSVG() {
     if (isDragging && activeDraggedElement) {
        activeDraggedElement.classList.remove('grabbing'); // Remove grabbing cursor class
        // Update the final state X based on the last translation
        const finalTransform = activeDraggedElement.transform.baseVal;
        const finalTranslateX = finalTransform.numberOfItems > 0 ? finalTransform.getItem(0).matrix.e : 0;

        if (activeDraggedDoor === 'left') {
            leftDoorState.x = finalTranslateX;
        } else {
            rightDoorState.x = finalTranslateX;
        }

     }
     isDragging = false;
     activeDraggedDoor = null;
     activeDraggedElement = null;
     // Optional: redrawSVG() could be called here if there were other drag-related visual changes
  }

  // --- Move Door with Keyboard ---
  function moveRightDoor(direction) {
    // Calculate new position
    let newX = rightDoorState.x;
    
    if (direction === 'left') {
      newX -= keyMoveStep;
    } else if (direction === 'right') {
      newX += keyMoveStep;
    }
    
    // Apply constraints
    const svgWidth = svg.width.baseVal.value;
    newX = Math.max(0, newX); // Prevent moving past left edge
    newX = Math.min(newX, svgWidth - doorWidthPx - scale); // Prevent moving past right edge (1cm buffer)
    
    // Update position
    rightDoorState.x = newX;
    rightDoorGroup.setAttribute('transform', `translate(${newX}, ${rightDoorState.y})`);
  }

  // Move left door with keyboard
  function moveLeftDoor(direction) {
    // Calculate new position
    let newX = leftDoorState.x;
    
    if (direction === 'left') {
      newX -= keyMoveStep;
    } else if (direction === 'right') {
      newX += keyMoveStep;
    }
    
    // Apply constraints
    const svgWidth = svg.width.baseVal.value;
    newX = Math.max(0, newX); // Prevent moving past left edge
    newX = Math.min(newX, svgWidth - doorWidthPx - scale); // Prevent moving past right edge (1cm buffer)
    
    // Update position
    leftDoorState.x = newX;
    leftDoorGroup.setAttribute('transform', `translate(${newX}, ${leftDoorState.y})`);
  }

  // --- Keyboard Event Listener ---
  window.addEventListener('keydown', (e) => {
    // Handle arrow keys for right door
    if (e.key === 'ArrowLeft') {
      moveRightDoor('left');
      e.preventDefault(); // Prevent scrolling
    } else if (e.key === 'ArrowRight') {
      moveRightDoor('right');
      e.preventDefault(); // Prevent scrolling
    }
    
    // Handle a/d keys for left door
    if (e.key === 'a' || e.key === 'A') {
      moveLeftDoor('left');
      e.preventDefault(); // Prevent scrolling
    } else if (e.key === 'd' || e.key === 'D') {
      moveLeftDoor('right');
      e.preventDefault(); // Prevent scrolling
    }
  });

  // --- Mouse Event Listeners ---
  svg.addEventListener('mousedown', (e) => {
    handleDragStartSVG(e);
  });

  // Attach move/end listeners to the window to catch events outside SVG
  window.addEventListener('mousemove', (e) => {
    if (isDragging) { // Only handle if dragging started on SVG
        handleDragMoveSVG(e);
    }
  });
  window.addEventListener('mouseup', handleDragEndSVG);


  // --- Touch Event Listeners ---
  svg.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) { // Single touch
        if (handleDragStartSVG(e)) {
            e.preventDefault(); // Prevent scrolling if drag started on a door
        }
    }
  }, { passive: false }); // Need passive: false to call preventDefault

  window.addEventListener('touchmove', (e) => {
    if (!isDragging) return; // Don't prevent scroll if not dragging
    e.preventDefault(); // Prevent scrolling while dragging
    if (e.touches.length === 1) {
        handleDragMoveSVG(e);
    }
  }, { passive: false });

  window.addEventListener('touchend', handleDragEndSVG);
  window.addEventListener('touchcancel', handleDragEndSVG);


  // --- Input Event Listeners ---
  // Global
  innerWidthInput.addEventListener('input', updateAndRedraw);
  innerHeightInput.addEventListener('input', updateAndRedraw);
  // Left Door Settings
  leftNumSectorsInput.addEventListener('input', updateAndRedraw);
  leftBlackAngleInput.addEventListener('input', updateAndRedraw);
  leftSpaceAngleInput.addEventListener('input', updateAndRedraw);
  leftVpOffsetInput.addEventListener('input', updateAndRedraw);
  leftDoorVisibility.addEventListener('change', function() {
    leftDoorState.visible = this.checked;
    redrawSVG();
  });
  
  // Right Door Settings
  rightNumSectorsInput.addEventListener('input', updateAndRedraw);
  rightBlackAngleInput.addEventListener('input', updateAndRedraw);
  rightSpaceAngleInput.addEventListener('input', updateAndRedraw);
  rightVpOffsetInput.addEventListener('input', updateAndRedraw);
  rightDoorVisibility.addEventListener('change', function() {
    rightDoorState.visible = this.checked;
    redrawSVG();
  });

  // A4 tiles visibility
  a4TilesVisibility.addEventListener('change', function() {
    redrawSVG();
  });

  // Print pages button
  printPagesBtn.addEventListener('click', function() {
    printA4Pages();
  });

  // Settings Toggle
  hamburgerBtn.addEventListener('click', () => {
      settingsPanel.classList.toggle('active');
  });

  closeSettingsBtn.addEventListener('click', () => {
      settingsPanel.classList.remove('active');
  });

  // --- Initial Setup ---
  updateAndRedraw(); // Calculate initial dimensions/settings and draw SVG

</script>

</body>
</html>
