<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Adjacent Doors Visualization</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f0f0;
            padding: 20px;
            font-family: sans-serif;
        }
        .container {
            display: flex;
            flex-direction: column; /* Stack controls and SVG vertically */
            align-items: center;
            width: 100%;
        }
        .controls-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px; /* Reduced space between left and right control sets */
            margin-bottom: 20px;
            width: 100%;
        }
        .door-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 1px solid #ccc;
            background-color: white;
            padding: 15px; /* Reduced padding */
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .door-controls h2 {
             margin-bottom: 10px; /* Reduced margin */
             font-size: 1rem; /* Slightly smaller heading */
             font-weight: 600;
        }
        .controls {
            display: flex;
            flex-direction: row; /* Arrange controls horizontally */
            flex-wrap: wrap; /* Allow controls to wrap if needed */
            gap: 10px; /* Reduced gap between controls */
            align-items: center; /* Vertically align items */
            justify-content: center; /* Center controls horizontally */
        }
        .control-group {
            display: flex;
            flex-direction: column; /* Stack label and input vertically */
            align-items: flex-start;
            width: auto; /* Allow width to be determined by content */
        }
        .control-group label {
            font-size: 0.8rem; /* Smaller label font size */
            color: #555;
            margin-bottom: 2px; /* Reduced margin */
            white-space: nowrap; /* Prevent label text from wrapping */
        }
         .control-group input[type="number"] {
            padding: 4px; /* Reduced padding */
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 60px; /* Fixed width for input for compactness */
            box-sizing: border-box;
            font-size: 0.9rem; /* Smaller input font size */
            text-align: center; /* Center text in input */
         }
         .control-group input[type="range"] {
             width: 100px; /* Adjust width for range slider */
             margin-top: 5px;
         }
        .zoom-controls {
            display: flex;
            justify-content: center;
            margin-top: 10px;
            gap: 10px;
        }
        .zoom-button {
            padding: 5px 10px;
            font-size: 1.2rem;
            cursor: pointer;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #fff;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
            min-width: 30px; /* Ensure minimum width for button */
            text-align: center;
        }
         .zoom-button:hover {
             background-color: #f0f0f0;
         }
         .zoom-button:active {
             background-color: #ddd;
         }

        svg {
            border: 1px solid #eee;
            background-color: white; /* SVG background */
            margin-top: 20px;
            max-width: 100%;
            height: auto;
             cursor: default;
        }
        /* Style for the draggable door groups */
        .draggable-door {
             cursor: grab;
        }
        .draggable-door:active {
            cursor: grabbing;
        }
    </style>
</head>
<body>

    <h1 class="text-3xl font-bold text-center mb-8">Interactive Adjacent Doors Visualization</h1>

    <div class="container">
        <div class="controls-container">
            <div class="door-controls">
                <h2>Left Door</h2>
                <div class="controls">
                    <div class="control-group">
                        <label for="leftGreenAngle">Green Angle:</label>
                        <input type="number" id="leftGreenAngle" value="3" min="0.1" step="0.1">
                    </div>
                     <div class="control-group">
                        <label for="leftBlueAngle">Blue Angle:</label>
                        <input type="number" id="leftBlueAngle" value="2" min="0.1" step="0.1">
                    </div>
                     <div class="control-group">
                        <label for="leftTotalGreenSectors">Total Green:</label>
                        <input type="number" id="leftTotalGreenSectors" value="19" min="1" step="1">
                    </div>
                     <div class="control-group">
                        <label for="leftInnerRectOpacity">Inner Rect Opacity:</label>
                        <input type="range" id="leftInnerRectOpacity" value="100" min="0" max="100" step="1">
                    </div>
                     <div class="control-group">
                        <label for="leftBlueSectorOpacity">Blue Sector Opacity:</label>
                        <input type="range" id="leftBlueSectorOpacity" value="70" min="0" max="100" step="1">
                    </div>
                </div>
            </div>

            <div class="door-controls">
                <h2>Right Door</h2>
                <div class="controls">
                    <div class="control-group">
                        <label for="rightGreenAngle">Green Angle:</label>
                        <input type="number" id="rightGreenAngle" value="3" min="0.1" step="0.1">
                    </div>
                     <div class="control-group">
                        <label for="rightBlueAngle">Blue Angle:</label>
                        <input type="number" id="rightBlueAngle" value="2" min="0.1" step="0.1">
                    </div>
                     <div class="control-group">
                        <label for="rightTotalGreenSectors">Total Green:</label>
                        <input type="number" id="rightTotalGreenSectors" value="19" min="1" step="1">
                    </div>
                     <div class="control-group">
                        <label for="rightInnerRectOpacity">Inner Rect Opacity:</label>
                        <input type="range" id="rightInnerRectOpacity" value="100" min="0" max="100" step="1">
                    </div>
                     <div class="control-group">
                        <label for="rightBlueSectorOpacity">Blue Sector Opacity:</label>
                        <input type="range" id="rightBlueSectorOpacity" value="70" min="0" max="100" step="1">
                    </div>
                </div>
            </div>
        </div>

        <div class="zoom-controls">
            <button id="zoomInButton" class="zoom-button">+</button>
            <button id="zoomOutButton" class="zoom-button">-</button>
            <button id="resetViewButton" class="zoom-button">Reset</button> </div>


        <svg id="doorsSVG" width="1600" height="1000" viewBox="-20 -250 880 1000">

            <defs>
                <clipPath id="leftInnerRectClip">
                    <rect x="0" y="0" width="400" height="250"/>
                </clipPath>
                 <clipPath id="rightInnerRectClip">
                    <rect x="440" y="0" width="400" height="250"/>
                </clipPath>
                <mask id="leftMask">
                    <!-- White base matching inner rect -->
                    <rect x="0" y="0" width="400" height="250" fill="white"/>
                    <!-- Black sectors (glass areas) will be added here by JS -->
                    <g id="leftMaskSectors"></g> 
                </mask>
                <mask id="rightMask">
                    <!-- White base matching inner rect -->
                    <rect x="440" y="0" width="400" height="250" fill="white"/>
                    <!-- Black sectors (glass areas) will be added here by JS -->
                    <g id="rightMaskSectors"></g>
                </mask>
            </defs>

            <g id="rightDoorGroup" class="draggable-door" mask="url(#rightMask)">
                <rect x="420" y="-20" width="440" height="290" stroke="#555" fill="#000000" stroke-width="2"/>
                <rect id="rightInnerRect" x="440" y="0" width="400" height="250" stroke="#333" fill="#ffffff" stroke-width="2"/>
                <circle cx="640" cy="300" r="2.5" fill="#ff6b6b" stroke="#c0392b" stroke-width="1"/>
                 <g id="rightSectorGroup"> <!-- Removed clip-path, mask handles visibility -->
                    </g>
            </g>

            <g id="leftDoorGroup" class="draggable-door" mask="url(#leftMask)">
                <rect x="-20" y="-20" width="440" height="290" stroke="#555" fill="#000000" stroke-width="2"/>
                <rect id="leftInnerRect" x="0" y="0" width="400" height="250" stroke="#333" fill="#ffffff" stroke-width="2"/>
                <circle cx="200" cy="300" r="2.5" fill="#ff6b6b" stroke="#c0392b" stroke-width="1"/>
                 <g id="leftSectorGroup"> <!-- Removed clip-path, mask handles visibility -->
                    </g>
            </g>


            </svg>

        <p class="text-center mt-4 text-gray-600">
            Adjust the sector angles, total green sectors, and transparency levels for each door.
            The sectors form a sequence starting and ending with green (black), with blue (white) sectors in between,
            clipped to the inner rectangles. The area between the outer (black, solid wood) and inner (white, with adjustable opacity glass)
            rectangles is black. All sectors have a radius of 37cm and are semi-transparent (with adjustable opacity for blue sectors).
            Use the + and - buttons to zoom in and out, and the Reset button to return to the initial view and door positions.
            Click and drag each door horizontally to move it. The Left Door will always appear on top when overlapping.
            The dimensions are represented in pixels (1cm = 10px).
        </p>
    </div>

    <script>
        function degToRad(degrees) {
            return degrees * (Math.PI / 180);
        }

        function getSectorPath(cx, cy, r, startAngleDeg, endAngleDeg) {
            const startAngleRad = degToRad(startAngleDeg);
            const endAngleRad = degToRad(endAngleDeg);

            const startX = cx + r * Math.cos(startAngleRad);
            const startY = cy + r * Math.sin(startAngleRad);

            const endX = cx + r * Math.cos(endAngleRad);
            const endY = cy + r * Math.sin(endAngleRad);

            const angleDifference = Math.abs(endAngleDeg - startAngleDeg);
            const largeArcFlag = angleDifference > 180 ? 1 : 0;
            const sweepFlag = endAngleDeg > startAngleDeg ? 1 : 0;

            return `M ${cx} ${cy} L ${startX} ${startY} A ${r} ${r} 0 ${largeArcFlag} ${sweepFlag} ${endX} ${endY} Z`;
        }

        // Function to get the center of the current viewBox
        function getViewBoxCenter(svgElement) {
             const viewBox = svgElement.getAttribute('viewBox').split(' ').map(Number);
             const minX = viewBox[0];
             const minY = viewBox[1];
             const width = viewBox[2];
             const height = viewBox[3];
             return { x: minX + width / 2, y: minY + height / 2 };
        }

        // Function to get the mouse position in SVG coordinates
        function getSvgMousePosition(event, svgElement) {
            const ctm = svgElement.getScreenCTM();
            const svgPoint = svgElement.createSVGPoint();
            svgPoint.x = event.clientX;
            svgPoint.y = event.clientY;
            return svgPoint.matrixTransform(ctm.inverse());
        }


        function updateDoorSectors(doorId) {
            const greenAngleInput = document.getElementById(`${doorId}GreenAngle`);
            const blueAngleInput = document.getElementById(`${doorId}BlueAngle`);
            const totalGreenSectorsInput = document.getElementById(`${doorId}TotalGreenSectors`);
            const innerRectOpacityInput = document.getElementById(`${doorId}InnerRectOpacity`);
            const blueSectorOpacityInput = document.getElementById(`${doorId}BlueSectorOpacity`);

            const innerRectElement = document.getElementById(`${doorId}InnerRect`);
            const sectorGroup = document.getElementById(`${doorId}SectorGroup`);
            const maskSectorGroup = document.getElementById(`${doorId}MaskSectors`); // Get the mask group

            const greenAngle = parseFloat(greenAngleInput.value);
            const blueAngle = parseFloat(blueAngleInput.value);
            const totalGreenSectors = parseInt(totalGreenSectorsInput.value);
            const innerRectOpacity = parseFloat(innerRectOpacityInput.value) / 100;
            const blueSectorOpacity = parseFloat(blueSectorOpacityInput.value) / 100;

            const radius = 370; // Radius is 370 pixels (37cm)

            // Determine VP coordinates based on doorId
            let vp_cx, vp_cy;
            if (doorId === 'left') {
                vp_cx = 200;
                vp_cy = 300;
            } else { // right
                vp_cx = 640; // Right VP is at x=640 in the SVG coordinate system
                vp_cy = 300;
            }

            const totalBlueSectors = totalGreenSectors > 0 ? totalGreenSectors - 1 : 0;
            const totalSectors = totalGreenSectors + totalBlueSectors;
            const totalAngle = (totalGreenSectors * greenAngle) + (totalBlueSectors * blueAngle);
            let currentAngle = 270 - (totalAngle / 2);

            // Clear existing sectors from the main group and the mask group
            while (sectorGroup.firstChild) {
                sectorGroup.removeChild(sectorGroup.firstChild);
            }
            while (maskSectorGroup.firstChild) {
                maskSectorGroup.removeChild(maskSectorGroup.firstChild);
            }

            // Generate Sectors 
            for (let i = 0; i < totalSectors; i++) {
                if (i % 2 === 0) { // Even index (0, 2, 4...) corresponds to Green (wood)
                    const sectorAngle = greenAngle;
                    const fillColor = '#000000'; // Wood color (black)
                    const strokeColor = '#222'; // Dark gray stroke
                    const fillOpacity = 0.7; // Keep green sectors semi-transparent (or make controllable?) - keeping 0.7 for now

                    let startAngle = currentAngle;
                    let endAngle = currentAngle + sectorAngle;

                    const pathData = getSectorPath(vp_cx, vp_cy, radius, startAngle, endAngle);
                    const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    pathElement.setAttribute('d', pathData);
                    pathElement.setAttribute('fill', fillColor);
                    pathElement.setAttribute('stroke', strokeColor);
                    pathElement.setAttribute('stroke-width', '1');
                    pathElement.setAttribute('fill-opacity', fillOpacity);
                    sectorGroup.appendChild(pathElement); // Add wood sector to main group

                    currentAngle = endAngle;
                } else { // Odd index (1, 3, 5...) corresponds to Blue (glass)
                    const sectorAngle = blueAngle;
                    const fillColor = 'black'; // Use black fill for mask transparency
                    const strokeColor = '#ccc'; // Light gray stroke
                    const fillOpacity = blueSectorOpacity; // Apply controlled opacity to blue sectors

                    let startAngle = currentAngle;
                    let endAngle = currentAngle + sectorAngle;

                    const pathData = getSectorPath(vp_cx, vp_cy, radius, startAngle, endAngle);
                    const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    pathElement.setAttribute('d', pathData);
                    pathElement.setAttribute('fill', fillColor);
                    pathElement.setAttribute('stroke', strokeColor);
                    pathElement.setAttribute('stroke-width', '1');
                    pathElement.setAttribute('fill-opacity', fillOpacity);
                    maskSectorGroup.appendChild(pathElement); // Add glass sector (as black) to mask group

                    currentAngle = endAngle;
                }
            }
        }

        // Drag functionality
        function enableDragging(doorGroupElement, svgElement) {
            let isDragging = false;
            let startMouseX;
            let startTranslateX = 0;

            // Get the initial translation from the element's transform attribute
            const initialTransform = doorGroupElement.getAttribute('transform');
            if (initialTransform && initialTransform.startsWith('translate(')) {
                const translateMatch = initialTransform.match(/translate\(([^,\s]+)(?:[,\s]+([^)]+))?\)/);
                 if (translateMatch && translateMatch[1]) {
                    startTranslateX = parseFloat(translateMatch[1]);
                 }
            }


            doorGroupElement.addEventListener('mousedown', (event) => {
                event.preventDefault(); // Prevent default drag behavior
                isDragging = true;
                const svgMousePosition = getSvgMousePosition(event, svgElement);
                startMouseX = svgMousePosition.x;

                 // Get the current translation before starting drag
                const currentTransform = doorGroupElement.getCTM();
                startTranslateX = currentTransform.e; // Get the current X translation on mousedown

                doorGroupElement.classList.add('dragging'); // Optional: Add a class for styling while dragging
            });

            // Add mousemove and mouseup listeners to the enti
            re document
            // This allows dragging even if the cursor leaves the element
            document.addEventListener('mousemove', (event) => {
                if (!isDragging) return;
                const svgMousePosition = getSvgMousePosition(event, svgElement); // Current mouse position in SVG coordinates
                const currentMouseX = svgMousePosition.x;

                const deltaX = currentMouseX - startMouseX; // Delta in SVG coordinates
                const newTranslateX = startTranslateX + deltaX; // New translation

                // Apply the horizontal translation
                doorGroupElement.setAttribute('transform', `translate(${newTranslateX}, 0)`);
            });

            document.addEventListener('mouseup', () => {
                if (!isDragging) return;
                isDragging = false;
                doorGroupElement.classList.remove('dragging'); // Optional: Remove dragging class
            });
        }


        // Zoom functionality
        function enableButtonZoom(svgElement, initialViewBox) {
            const zoomInButton = document.getElementById('zoomInButton');
            const zoomOutButton = document.getElementById('zoomOutButton');
            const resetButton = document.getElementById('resetViewButton'); // Get the reset button
            const zoomStep = 0.1; // Adjust zoom step for buttons

            zoomInButton.addEventListener('click', () => {
                const viewBox = svgElement.getAttribute('viewBox').split(' ').map(Number);
                let minX = viewBox[0];
                let minY = viewBox[1];
                let width = viewBox[2];
                let height = viewBox[3];

                const zoomFactor = 1.0 - zoomStep; // Zoom in

                const newWidth = width * zoomFactor;
                const newHeight = height * zoomFactor;

                // Zoom towards the center of the current viewBox
                const center = getViewBoxCenter(svgElement);
                const newMinX = center.x - (center.x - minX) * zoomFactor;
                const newMinY = center.y - (center.y - minY) * zoomFactor;


                svgElement.setAttribute('viewBox', `${newMinX} ${newMinY} ${newWidth} ${newHeight}`);
            });

            zoomOutButton.addEventListener('click', () => {
                 const viewBox = svgElement.getAttribute('viewBox').split(' ').map(Number);
                let minX = viewBox[0];
                let minY = viewBox[1];
                let width = viewBox[2];
                let height = viewBox[3];

                const zoomFactor = 1.0 + zoomStep; // Zoom out

                const newWidth = width * zoomFactor;
                const newHeight = height * zoomFactor;

                 // Zoom from the center of the current viewBox
                const center = getViewBoxCenter(svgElement);
                const newMinX = center.x - (center.x - minX) * zoomFactor;
                const newMinY = center.y - (center.y - minY) * zoomFactor;

                svgElement.setAttribute('viewBox', `${newMinX} ${newMinY} ${newWidth} ${newHeight}`);
            });

            // Reset button event listener
            resetButton.addEventListener('click', () => {
                svgElement.setAttribute('viewBox', initialViewBox); // Set viewBox back to initial value

                // Reset door positions
                document.getElementById('leftDoorGroup').setAttribute('transform', 'translate(0, 0)'); // Reset left door translation
                document.getElementById('rightDoorGroup').setAttribute('transform', 'translate(0, 0)'); // Reset right door translation
            });
        }


        document.addEventListener('DOMContentLoaded', () => {
            // Get elements for both doors
            const leftGreenAngleInput = document.getElementById('leftGreenAngle');
            const leftBlueAngleInput = document.getElementById('leftBlueAngle');
            const leftTotalGreenSectorsInput = document.getElementById('leftTotalGreenSectors');
            const leftInnerRectOpacityInput = document.getElementById('leftInnerRectOpacity');
            const leftBlueSectorOpacityInput = document.getElementById('leftBlueSectorOpacity');


            const rightGreenAngleInput = document.getElementById('rightGreenAngle');
            const rightBlueAngleInput = document.getElementById('rightBlueAngle');
            const rightTotalGreenSectorsInput = document.getElementById('rightTotalGreenSectors');
            const rightInnerRectOpacityInput = document.getElementById('rightInnerRectOpacity');
            const rightBlueSectorOpacityInput = document.getElementById('rightBlueSectorOpacity');


            const doorsSvg = document.getElementById('doorsSVG'); // Get the single SVG
            const leftDoorGroup = document.getElementById('leftDoorGroup'); // Get left door group
            const rightDoorGroup = document.getElementById('rightDoorGroup'); // Get right door group

            // Store the initial viewBox value
            const initialViewBox = doorsSvg.getAttribute('viewBox');

            // Store the initial transform for each door group (should be translate(0, 0) initially)
            // We can get this from the element's CTM or assume it's translate(0,0) if no transform is set initially.
            // Let's explicitly set it and then get it to be safe.
             leftDoorGroup.setAttribute('transform', 'translate(0, 0)');
             rightDoorGroup.setAttribute('transform', 'translate(0, 0)');
             const initialLeftDoorTransform = leftDoorGroup.getAttribute('transform');
             const initialRightDoorTransform = rightDoorGroup.getAttribute('transform');


            // Initial render for both doors
            updateDoorSectors('left');
            updateDoorSectors('right');

            // Enable button zoom and reset for the single SVG
            enableButtonZoom(doorsSvg, initialViewBox);

            // Enable dragging for each door group
            enableDragging(leftDoorGroup, doorsSvg);
            enableDragging(rightDoorGroup, doorsSVG);


            // Add event listeners for left door controls
            leftGreenAngleInput.addEventListener('input', () => updateDoorSectors('left'));
            leftBlueAngleInput.addEventListener('input', () => updateDoorSectors('left'));
            leftTotalGreenSectorsInput.addEventListener('input', () => updateDoorSectors('left'));
            leftInnerRectOpacityInput.addEventListener('input', () => updateDoorSectors('left')); // Add listener for inner rect opacity
            leftBlueSectorOpacityInput.addEventListener('input', () => updateDoorSectors('left')); // Add listener for blue sector opacity


            // Add event listeners for right door controls
            rightGreenAngleInput.addEventListener('input', () => updateDoorSectors('right'));
            rightBlueAngleInput.addEventListener('input', () => updateDoorSectors('right'));
            rightTotalGreenSectorsInput.addEventListener('input', () => updateDoorSectors('right'));
            rightInnerRectOpacityInput.addEventListener('input', () => updateDoorSectors('right')); // Add listener for inner rect opacity
            rightBlueSectorOpacityInput.addEventListener('input', () => updateDoorSectors('right')); // Add listener for blue sector opacity
        });

    </script>

</body>
</html>
