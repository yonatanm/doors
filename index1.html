<!DOCTYPE html>
<html>
<head>
<title>Canvas Door</title>
<style>
  body { margin: 0; overflow: hidden; background-color: #f0f0f0; font-family: sans-serif;}
  canvas { border: 1px solid black; display: block; margin-top: 10px;}
  .controls { padding: 10px; background-color: #eee; border: 1px solid #ccc; margin-bottom: 10px; }
  .controls legend { font-weight: bold; margin-bottom: 5px; }
  .controls div { margin-bottom: 5px; }
  .controls label { display: inline-block; min-width: 150px; margin-right: 5px; text-align: right; }
  .controls input { width: 60px; margin-right: 5px;}
  .controls span { display: inline-block; min-width: 25px; text-align: right;}

  .settings-container {
    display: flex;
    flex-direction: row; /* Arrange items horizontally */
    flex-wrap: wrap; /* Allow wrapping if needed */
    gap: 15px; /* Add space between fieldsets */
    margin-bottom: 10px; /* Space below the container */
  }
  .settings-container .controls {
      margin-bottom: 0; /* Remove bottom margin from individual fieldsets */
      flex: 1; /* Allow fieldsets to grow */
      min-width: 250px; /* Prevent them from becoming too narrow */
  }
</style>
</head>
<body>

<div class="settings-container">
    <fieldset class="controls">
      <legend>Global Settings</legend>
      <div>
        <label for="innerWidthInput">Inner Width (cm):</label>
        <input type="number" id="innerWidthInput" value="40" min="10" max="100" step="1">
        <span id="innerWidthValue">40</span> cm
      </div>
      <div>
        <label for="innerHeightInput">Inner Height (cm):</label>
        <input type="number" id="innerHeightInput" value="20" min="10" max="60" step="1">
        <span id="innerHeightValue">20</span> cm
      </div>
      <div>
        <label for="vpOffsetInput">VP Offset Y (cm):</label>
        <input type="number" id="vpOffsetInput" value="5" min="0" max="20" step="1">
        <span id="vpOffsetValue">5</span> cm
      </div>
    </fieldset>

    <fieldset class="controls">
        <legend>Left Door Settings</legend>
        <div>
            <label for="leftNumSectorsInput">Num Black Sectors:</label>
            <input type="number" id="leftNumSectorsInput" value="19" min="1" max="50" step="1">
            <span id="leftNumSectorsValue">19</span>
        </div>
        <div>
            <label for="leftBlackAngleInput">Black Sector Angle:</label>
            <input type="number" id="leftBlackAngleInput" value="3" min="0.1" max="45" step="0.1">
            <span id="leftBlackAngleValue">3.0</span> deg
        </div>
        <div>
            <label for="leftSpaceAngleInput">Space Angle:</label>
            <input type="number" id="leftSpaceAngleInput" value="2" min="0" max="45" step="0.1">
            <span id="leftSpaceAngleValue">2.0</span> deg
        </div>
    </fieldset>

    <fieldset class="controls">
        <legend>Right Door Settings</legend>
        <div>
            <label for="rightNumSectorsInput">Num Black Sectors:</label>
            <input type="number" id="rightNumSectorsInput" value="19" min="1" max="50" step="1">
            <span id="rightNumSectorsValue">19</span>
        </div>
        <div>
            <label for="rightBlackAngleInput">Black Sector Angle:</label>
            <input type="number" id="rightBlackAngleInput" value="3" min="0.1" max="45" step="0.1">
            <span id="rightBlackAngleValue">3.0</span> deg
        </div>
        <div>
            <label for="rightSpaceAngleInput">Space Angle:</label>
            <input type="number" id="rightSpaceAngleInput" value="2" min="0" max="45" step="0.1">
            <span id="rightSpaceAngleValue">2.0</span> deg
        </div>
    </fieldset>
</div>

<canvas id="doorCanvas" width="100" height="50"></canvas>

<script>
  const canvas = document.getElementById('doorCanvas');
  const ctx = canvas.getContext('2d');

  // Get Global control elements
  const innerWidthInput = document.getElementById('innerWidthInput');
  const innerHeightInput = document.getElementById('innerHeightInput');
  const vpOffsetInput = document.getElementById('vpOffsetInput');
  const innerWidthValueSpan = document.getElementById('innerWidthValue');
  const innerHeightValueSpan = document.getElementById('innerHeightValue');
  const vpOffsetValueSpan = document.getElementById('vpOffsetValue');

  // Get Left Door Setting control elements
  const leftNumSectorsInput = document.getElementById('leftNumSectorsInput');
  const leftBlackAngleInput = document.getElementById('leftBlackAngleInput');
  const leftSpaceAngleInput = document.getElementById('leftSpaceAngleInput');
  const leftNumSectorsValueSpan = document.getElementById('leftNumSectorsValue');
  const leftBlackAngleValueSpan = document.getElementById('leftBlackAngleValue');
  const leftSpaceAngleValueSpan = document.getElementById('leftSpaceAngleValue');

  // Get Right Door Setting control elements
  const rightNumSectorsInput = document.getElementById('rightNumSectorsInput');
  const rightBlackAngleInput = document.getElementById('rightBlackAngleInput');
  const rightSpaceAngleInput = document.getElementById('rightSpaceAngleInput');
  const rightNumSectorsValueSpan = document.getElementById('rightNumSectorsValue');
  const rightBlackAngleValueSpan = document.getElementById('rightBlackAngleValue');
  const rightSpaceAngleValueSpan = document.getElementById('rightSpaceAngleValue');

  // --- Door Properties (Constants and Dynamic State) ---
  const scale = 15; // Increased scale again (pixels per cm)
  const borderWidthCm = 2;
  const borderWidthPx = borderWidthCm * scale; // Auto-updates
  const vpRadiusCm = 1;
  const vpRadiusPx = vpRadiusCm * scale; // 5px
  const sectorRadiusCm = 37;
  const sectorRadiusPx = sectorRadiusCm * scale;

  // State variables - Global
  let innerWidthCm = 40;
  let innerHeightCm = 20;
  let vpOffsetYCm = 5;

  // Calculated global dimensions (will be updated in updateAndRedraw)
  let doorWidthCm, doorHeightCm, doorWidthPx, doorHeightPx, vpOffsetYPx;

  // --- Door States (Position and Settings) ---
  let leftDoorState = {
    x: 0, y: 0,
    numBlackSectors: 19,
    blackSectorDeg: 3,
    spaceSectorDeg: 2,
    blackSectorRad: 0, // Calculated
    spaceSectorRad: 0  // Calculated
  };
  let rightDoorState = {
    x: 0, y: 0,
    numBlackSectors: 19,
    blackSectorDeg: 3,
    spaceSectorDeg: 2,
    blackSectorRad: 0, // Calculated
    spaceSectorRad: 0  // Calculated
  };

  // --- Drag State ---
  let isDragging = false;
  let dragOffsetX = 0;
  let activeDraggedDoor = null; // 'left' or 'right'

  // --- Update State from Inputs & Redraw ---
  function updateAndRedraw() {
    // Read global values from inputs
    innerWidthCm = parseFloat(innerWidthInput.value);
    innerHeightCm = parseFloat(innerHeightInput.value);
    vpOffsetYCm = parseFloat(vpOffsetInput.value);

    // Read left door settings values from inputs
    leftDoorState.numBlackSectors = parseInt(leftNumSectorsInput.value);
    leftDoorState.blackSectorDeg = parseFloat(leftBlackAngleInput.value);
    leftDoorState.spaceSectorDeg = parseFloat(leftSpaceAngleInput.value);

    // Read right door settings values from inputs
    rightDoorState.numBlackSectors = parseInt(rightNumSectorsInput.value);
    rightDoorState.blackSectorDeg = parseFloat(rightBlackAngleInput.value);
    rightDoorState.spaceSectorDeg = parseFloat(rightSpaceAngleInput.value);

    // Update display spans
    innerWidthValueSpan.textContent = innerWidthCm;
    innerHeightValueSpan.textContent = innerHeightCm;
    vpOffsetValueSpan.textContent = vpOffsetYCm;
    // Left
    leftNumSectorsValueSpan.textContent = leftDoorState.numBlackSectors;
    leftBlackAngleValueSpan.textContent = leftDoorState.blackSectorDeg.toFixed(1);
    leftSpaceAngleValueSpan.textContent = leftDoorState.spaceSectorDeg.toFixed(1);
    // Right
    rightNumSectorsValueSpan.textContent = rightDoorState.numBlackSectors;
    rightBlackAngleValueSpan.textContent = rightDoorState.blackSectorDeg.toFixed(1);
    rightSpaceAngleValueSpan.textContent = rightDoorState.spaceSectorDeg.toFixed(1);

    // Recalculate total door dimensions based on inner dimensions + border
    doorWidthCm = innerWidthCm + (borderWidthCm * 2);
    doorHeightCm = innerHeightCm + (borderWidthCm * 2);

    // Recalculate global pixel values
    doorWidthPx = doorWidthCm * scale;
    doorHeightPx = doorHeightCm * scale;
    vpOffsetYPx = vpOffsetYCm * scale;

    // Recalculate door-specific pixel values (radians)
    leftDoorState.blackSectorRad = leftDoorState.blackSectorDeg * Math.PI / 180;
    leftDoorState.spaceSectorRad = leftDoorState.spaceSectorDeg * Math.PI / 180;
    rightDoorState.blackSectorRad = rightDoorState.blackSectorDeg * Math.PI / 180;
    rightDoorState.spaceSectorRad = rightDoorState.spaceSectorDeg * Math.PI / 180;

    // --- Dynamic Canvas Resizing ---
    const targetCanvasWidth = doorWidthPx * 2;
    const targetCanvasHeight = targetCanvasWidth / 2; // Maintain 2:1 aspect ratio

    if (canvas.width !== targetCanvasWidth || canvas.height !== targetCanvasHeight) {
        console.log(`Resizing canvas: DoorWidthPx=${doorWidthPx.toFixed(1)}, TargetCanvasWidth=${targetCanvasWidth.toFixed(1)}`); // Added Log
        canvas.width = targetCanvasWidth;
        canvas.height = targetCanvasHeight;
    }
    // --- End Resizing ---

    // Recalculate door positions ONLY if not currently dragging
    if (!isDragging) {
      // When canvas width is exactly 2*doorWidth, doors start at the edges
      leftDoorState.x = 0;
      rightDoorState.x = doorWidthPx;
      // Keep Y centered
      const centeredY = (canvas.height - doorHeightPx) / 2;
      leftDoorState.y = centeredY;
      rightDoorState.y = centeredY;
    }
    // If dragging, update Y position if height changed
    else {
        const centeredY = (canvas.height - doorHeightPx) / 2;
        leftDoorState.y = centeredY;
        rightDoorState.y = centeredY;
        // Ensure dragged door stays within new bounds after resize
        if (activeDraggedDoor === 'left') {
            leftDoorState.x = Math.max(0, leftDoorState.x);
            leftDoorState.x = Math.min(leftDoorState.x, canvas.width - doorWidthPx);
        } else if (activeDraggedDoor === 'right') {
            rightDoorState.x = Math.max(0, rightDoorState.x);
            rightDoorState.x = Math.min(rightDoorState.x, canvas.width - doorWidthPx);
        }
    }

    redraw(); // Redraw with new dimensions/settings/positions
  }


  // --- Draw Single Door and VP ---
  function drawDoor(doorState) {
    const { x, y, numBlackSectors, blackSectorRad, spaceSectorRad } = doorState; // Use settings from state
    // --- Calculations ---
    // Calculate inner dimensions directly from global door dimensions and border
    const innerWidthPx = doorWidthPx - (borderWidthPx * 2);
    const innerHeightPx = doorHeightPx - (borderWidthPx * 2);
    const innerRectX = x + borderWidthPx;
    const innerRectY = y + borderWidthPx;
    const vpCenterX = x + doorWidthPx / 2;
    const vpCenterY = y + doorHeightPx + vpOffsetYPx;

    // --- Drawing ---
    ctx.save(); // Save context for this door

    // 1. Draw the border
    ctx.strokeStyle = 'black';
    ctx.lineWidth = borderWidthPx;
    ctx.strokeRect(
      x + borderWidthPx / 2,
      y + borderWidthPx / 2,
      innerWidthPx,
      innerHeightPx
    );

    // 2. Draw Sectors inside the inner bounds
    ctx.save(); // Save context before clipping
    ctx.beginPath();
    ctx.rect(innerRectX, innerRectY, innerWidthPx, innerHeightPx);
    ctx.clip();

    const numSpaces = Math.max(0, numBlackSectors - 1);
    const totalAngleRad = (numBlackSectors * blackSectorRad) + (numSpaces * spaceSectorRad);
    const startAngle = (-Math.PI / 2) - (totalAngleRad / 2);
    const stepRad = blackSectorRad + spaceSectorRad;
    ctx.fillStyle = 'black';
    let currentAngle = startAngle;
    for (let i = 0; i < numBlackSectors; i++) {
        const endAngle = currentAngle + blackSectorRad;
        if (blackSectorRad > 0) {
             ctx.beginPath();
             ctx.moveTo(vpCenterX, vpCenterY);
             ctx.arc(vpCenterX, vpCenterY, sectorRadiusPx, currentAngle, endAngle);
             ctx.closePath();
             ctx.fill();
        }
        currentAngle += stepRad;
    }
    ctx.restore(); // Restore context to remove clipping

    // 3. Draw the VP circle (after clipping restore)
    ctx.fillStyle = 'blue';
    ctx.beginPath();
    ctx.arc(vpCenterX, vpCenterY, vpRadiusPx, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore(); // Restore context for this door
  }

  // --- Redraw Canvas ---
  function redraw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Draw both doors using their state
    drawDoor(leftDoorState);
    drawDoor(rightDoorState);
  }

  // --- Mouse Event Handlers --- (No changes needed here for settings)
  canvas.addEventListener('mousedown', (e) => {
    const mouseX = e.offsetX;
    const mouseY = e.offsetY;

    // Check left door first (higher z-index visually if overlapping)
    if (mouseX >= leftDoorState.x && mouseX <= leftDoorState.x + doorWidthPx &&
        mouseY >= leftDoorState.y && mouseY <= leftDoorState.y + doorHeightPx) {
      isDragging = true;
      activeDraggedDoor = 'left';
      dragOffsetX = mouseX - leftDoorState.x;
      canvas.style.cursor = 'grabbing';
    }
    // Check right door if left not hit
    else if (mouseX >= rightDoorState.x && mouseX <= rightDoorState.x + doorWidthPx &&
             mouseY >= rightDoorState.y && mouseY <= rightDoorState.y + doorHeightPx) {
       isDragging = true;
       activeDraggedDoor = 'right';
       dragOffsetX = mouseX - rightDoorState.x;
       canvas.style.cursor = 'grabbing';
    }
  });

  canvas.addEventListener('mousemove', (e) => {
    if (!isDragging || !activeDraggedDoor) return;

    const mouseX = e.offsetX;
    let newX = mouseX - dragOffsetX;

    // Apply constraints based on which door is dragged
    if (activeDraggedDoor === 'left') {
        // Clamp only to canvas left edge
        newX = Math.max(0, newX);
        // Allow overlap
        newX = Math.min(newX, canvas.width - doorWidthPx); // Clamp to right edge too
        leftDoorState.x = newX;
    } else { // activeDraggedDoor === 'right'
        // Clamp only to canvas edges
        newX = Math.max(0, newX); // Clamp to left edge
        newX = Math.min(newX, canvas.width - doorWidthPx);
        rightDoorState.x = newX;
    }

    redraw();
  });

  const stopDragging = () => {
     if (isDragging) {
       isDragging = false;
       activeDraggedDoor = null; // Clear active door
       canvas.style.cursor = 'grab';
       redraw(); // Redraw in final position
    }
  };
  canvas.addEventListener('mouseup', stopDragging);
  canvas.addEventListener('mouseleave', stopDragging);

  // --- Input Event Listeners ---
  // Global
  innerWidthInput.addEventListener('input', updateAndRedraw);
  innerHeightInput.addEventListener('input', updateAndRedraw);
  vpOffsetInput.addEventListener('input', updateAndRedraw);
  // Left Door Settings
  leftNumSectorsInput.addEventListener('input', updateAndRedraw);
  leftBlackAngleInput.addEventListener('input', updateAndRedraw);
  leftSpaceAngleInput.addEventListener('input', updateAndRedraw);
  // Right Door Settings
  rightNumSectorsInput.addEventListener('input', updateAndRedraw);
  rightBlackAngleInput.addEventListener('input', updateAndRedraw);
  rightSpaceAngleInput.addEventListener('input', updateAndRedraw);


  // --- Initial Setup ---
  updateAndRedraw(); // Calculate initial dimensions/settings and draw
  canvas.style.cursor = 'grab';

</script>

</body>
</html>
