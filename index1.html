<!DOCTYPE html>
<html>
<head>
<title>Canvas Door</title>
<style>
  body { margin: 0; overflow: hidden; background-color: #f0f0f0; font-family: sans-serif;}
  canvas { border: 1px solid black; display: block; margin-top: 10px;}
  .controls { padding: 10px; background-color: #eee; border: 1px solid #ccc; margin-bottom: 10px; }
  .controls legend { font-weight: bold; margin-bottom: 5px; }
  .controls div { margin-bottom: 5px; }
  .controls label { display: inline-block; min-width: 150px; margin-right: 5px; text-align: right; }
  .controls input { width: 60px; margin-right: 5px;}
  .controls span { display: inline-block; min-width: 25px; text-align: right;}
</style>
</head>
<body>

<fieldset class="controls">
  <legend>Global Settings</legend>
  <div>
    <label for="innerWidthInput">Inner Width (cm):</label>
    <input type="number" id="innerWidthInput" value="40" min="10" max="100" step="1">
    <span id="innerWidthValue">40</span> cm
  </div>
  <div>
    <label for="innerHeightInput">Inner Height (cm):</label>
    <input type="number" id="innerHeightInput" value="20" min="10" max="60" step="1">
    <span id="innerHeightValue">20</span> cm
  </div>
    <div>
    <label for="vpOffsetInput">VP Offset Y (cm):</label>
    <input type="number" id="vpOffsetInput" value="5" min="0" max="20" step="1">
    <span id="vpOffsetValue">5</span> cm
  </div>
</fieldset>

<fieldset class="controls">
    <legend>Door Settings</legend>
    <div>
        <label for="numSectorsInput">Num Black Sectors:</label>
        <input type="number" id="numSectorsInput" value="19" min="1" max="50" step="2"> <!-- Step 2 to keep it odd? Or allow even? Let's allow any for now -->
        <span id="numSectorsValue">19</span>
    </div>
    <div>
        <label for="blackAngleInput">Black Sector Angle:</label>
        <input type="number" id="blackAngleInput" value="3" min="0.1" max="45" step="0.1">
        <span id="blackAngleValue">3</span> deg
    </div>
    <div>
        <label for="spaceAngleInput">Space Angle:</label>
        <input type="number" id="spaceAngleInput" value="2" min="0" max="45" step="0.1">
        <span id="spaceAngleValue">2</span> deg
    </div>
</fieldset>

<canvas id="doorCanvas" width="800" height="400"></canvas>

<script>
  const canvas = document.getElementById('doorCanvas');
  const ctx = canvas.getContext('2d');

  // Get Global control elements
  const innerWidthInput = document.getElementById('innerWidthInput');
  const innerHeightInput = document.getElementById('innerHeightInput');
  const vpOffsetInput = document.getElementById('vpOffsetInput');
  const innerWidthValueSpan = document.getElementById('innerWidthValue');
  const innerHeightValueSpan = document.getElementById('innerHeightValue');
  const vpOffsetValueSpan = document.getElementById('vpOffsetValue');

  // Get Door Setting control elements
  const numSectorsInput = document.getElementById('numSectorsInput');
  const blackAngleInput = document.getElementById('blackAngleInput');
  const spaceAngleInput = document.getElementById('spaceAngleInput');
  const numSectorsValueSpan = document.getElementById('numSectorsValue');
  const blackAngleValueSpan = document.getElementById('blackAngleValue');
  const spaceAngleValueSpan = document.getElementById('spaceAngleValue');


  // --- Draw Flower --- (Fixed position)
  function drawFlower(x, y) {
    // Center (yellow)
    ctx.fillStyle = 'yellow';
    ctx.beginPath();
    ctx.arc(x, y, 15, 0, Math.PI * 2);
    ctx.fill();

    // Petals (red)
    ctx.fillStyle = 'red';
    const petalLength = 30;
    const petalWidth = 10;
    for (let i = 0; i < 6; i++) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate((Math.PI / 3) * i);
      ctx.beginPath();
      ctx.ellipse(0, -petalLength / 2 - 10, petalWidth, petalLength, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  const flowerX = canvas.width / 2; // Centered flower
  const flowerY = canvas.height / 2;

  // --- Door Properties (Constants and Dynamic State) ---
  const scale = 5; // 5 pixels per cm
  const borderWidthCm = 2;
  const borderWidthPx = borderWidthCm * scale; // 10px
  const vpRadiusCm = 1;
  const vpRadiusPx = vpRadiusCm * scale; // 5px
  const sectorRadiusCm = 37;
  const sectorRadiusPx = sectorRadiusCm * scale;

  // State variables - Global
  let innerWidthCm = 40;
  let innerHeightCm = 20;
  let vpOffsetYCm = 5;

  // State variables - Door Settings
  let numBlackSectors = 19;
  let blackSectorDeg = 3;
  let spaceSectorDeg = 2;

  // Calculated dimensions (will be updated in updateAndRedraw)
  let doorWidthCm, doorHeightCm, doorWidthPx, doorHeightPx, vpOffsetYPx;
  let blackSectorRad, spaceSectorRad;

  // --- Door States ---
  let leftDoorState = { x: 0, y: 0 };
  let rightDoorState = { x: 0, y: 0 };

  // --- Drag State ---
  let isDragging = false;
  let dragOffsetX = 0;
  let activeDraggedDoor = null; // 'left' or 'right'

  // --- Update State from Inputs & Redraw ---
  function updateAndRedraw() {
    // Read global values from inputs
    innerWidthCm = parseFloat(innerWidthInput.value);
    innerHeightCm = parseFloat(innerHeightInput.value);
    vpOffsetYCm = parseFloat(vpOffsetInput.value);

    // Read door settings values from inputs
    numBlackSectors = parseInt(numSectorsInput.value);
    blackSectorDeg = parseFloat(blackAngleInput.value);
    spaceSectorDeg = parseFloat(spaceAngleInput.value);

    // Update display spans
    innerWidthValueSpan.textContent = innerWidthCm;
    innerHeightValueSpan.textContent = innerHeightCm;
    vpOffsetValueSpan.textContent = vpOffsetYCm;
    numSectorsValueSpan.textContent = numBlackSectors;
    blackAngleValueSpan.textContent = blackSectorDeg.toFixed(1);
    spaceAngleValueSpan.textContent = spaceSectorDeg.toFixed(1);

    // Recalculate total door dimensions based on inner dimensions + border
    doorWidthCm = innerWidthCm + (borderWidthCm * 2);
    doorHeightCm = innerHeightCm + (borderWidthCm * 2);

    // Recalculate pixel values
    doorWidthPx = doorWidthCm * scale;
    doorHeightPx = doorHeightCm * scale;
    vpOffsetYPx = vpOffsetYCm * scale;
    blackSectorRad = blackSectorDeg * Math.PI / 180;
    spaceSectorRad = spaceSectorDeg * Math.PI / 180;

    // Recalculate door positions ONLY if not currently dragging
    if (!isDragging) {
      const totalCombinedWidth = doorWidthPx * 2;
      const startX = (canvas.width - totalCombinedWidth) / 2;
      const centeredY = (canvas.height - doorHeightPx) / 2;

      leftDoorState.x = Math.max(0, startX); // Ensure it starts within bounds if canvas too small
      leftDoorState.y = centeredY;
      rightDoorState.x = Math.min(canvas.width - doorWidthPx, leftDoorState.x + doorWidthPx);
      rightDoorState.y = centeredY;
    }
    // If dragging, the position is handled by mousemove, but ensure Y is updated if height changes
    else {
        const centeredY = (canvas.height - doorHeightPx) / 2;
        leftDoorState.y = centeredY;
        rightDoorState.y = centeredY;
        // Keep doors adjacent if dimensions changed during drag (might cause slight jump)
        if (activeDraggedDoor === 'left') {
            rightDoorState.x = leftDoorState.x + doorWidthPx;
        } else if (activeDraggedDoor === 'right') {
            leftDoorState.x = rightDoorState.x - doorWidthPx;
        }
    }

    redraw(); // Redraw with new dimensions/settings/positions
  }


  // --- Draw Single Door and VP ---
  function drawDoor(doorState) {
    const { x, y } = doorState;
    // --- Calculations ---
    const innerWidthPx = innerWidthCm * scale;
    const innerHeightPx = innerHeightCm * scale;
    const innerRectX = x + borderWidthPx;
    const innerRectY = y + borderWidthPx;
    const vpCenterX = x + doorWidthPx / 2;
    const vpCenterY = y + doorHeightPx + vpOffsetYPx;

    // --- Drawing ---
    ctx.save(); // Save context for this door

    // 1. Draw the border
    ctx.strokeStyle = 'black';
    ctx.lineWidth = borderWidthPx;
    ctx.strokeRect(
      x + borderWidthPx / 2,
      y + borderWidthPx / 2,
      innerWidthPx,
      innerHeightPx
    );

    // 2. Draw Sectors inside the inner bounds
    ctx.save(); // Save context before clipping
    ctx.beginPath();
    ctx.rect(innerRectX, innerRectY, innerWidthPx, innerHeightPx);
    ctx.clip();

    const numSpaces = Math.max(0, numBlackSectors - 1);
    const totalAngleRad = (numBlackSectors * blackSectorRad) + (numSpaces * spaceSectorRad);
    const startAngle = (-Math.PI / 2) - (totalAngleRad / 2);
    const stepRad = blackSectorRad + spaceSectorRad;
    ctx.fillStyle = 'black';
    let currentAngle = startAngle;
    for (let i = 0; i < numBlackSectors; i++) {
        const endAngle = currentAngle + blackSectorRad;
        if (blackSectorRad > 0) {
             ctx.beginPath();
             ctx.moveTo(vpCenterX, vpCenterY);
             ctx.arc(vpCenterX, vpCenterY, sectorRadiusPx, currentAngle, endAngle);
             ctx.closePath();
             ctx.fill();
        }
        currentAngle += stepRad;
    }
    ctx.restore(); // Restore context to remove clipping

    // 3. Draw the VP circle (after clipping restore)
    ctx.fillStyle = 'blue';
    ctx.beginPath();
    ctx.arc(vpCenterX, vpCenterY, vpRadiusPx, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore(); // Restore context for this door
  }

  // --- Redraw Canvas ---
  function redraw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawFlower(flowerX, flowerY);
    // Draw both doors using their state
    drawDoor(leftDoorState);
    drawDoor(rightDoorState);
  }

  // --- Mouse Event Handlers ---
  canvas.addEventListener('mousedown', (e) => {
    const mouseX = e.offsetX;
    const mouseY = e.offsetY;

    // Check left door first
    if (mouseX >= leftDoorState.x && mouseX <= leftDoorState.x + doorWidthPx &&
        mouseY >= leftDoorState.y && mouseY <= leftDoorState.y + doorHeightPx) {
      isDragging = true;
      activeDraggedDoor = 'left';
      dragOffsetX = mouseX - leftDoorState.x;
      canvas.style.cursor = 'grabbing';
    }
    // Check right door if left not hit
    else if (mouseX >= rightDoorState.x && mouseX <= rightDoorState.x + doorWidthPx &&
             mouseY >= rightDoorState.y && mouseY <= rightDoorState.y + doorHeightPx) {
       isDragging = true;
       activeDraggedDoor = 'right';
       dragOffsetX = mouseX - rightDoorState.x;
       canvas.style.cursor = 'grabbing';
    }
  });

  canvas.addEventListener('mousemove', (e) => {
    if (!isDragging || !activeDraggedDoor) return;

    const mouseX = e.offsetX;
    let newX = mouseX - dragOffsetX;

    // Apply constraints based on which door is dragged
    if (activeDraggedDoor === 'left') {
        // Clamp only to canvas left edge
        newX = Math.max(0, newX);
        leftDoorState.x = newX;
    } else { // activeDraggedDoor === 'right'
        // Clamp only to canvas right edge
        newX = Math.min(newX, canvas.width - doorWidthPx);
        rightDoorState.x = newX;
    }

    redraw();
  });

  const stopDragging = () => {
     if (isDragging) {
       isDragging = false;
       activeDraggedDoor = null; // Clear active door
       canvas.style.cursor = 'grab';
       redraw(); // Redraw in final position
    }
  };
  canvas.addEventListener('mouseup', stopDragging);
  canvas.addEventListener('mouseleave', stopDragging);

  // --- Input Event Listeners ---
  // Global
  innerWidthInput.addEventListener('input', updateAndRedraw);
  innerHeightInput.addEventListener('input', updateAndRedraw);
  vpOffsetInput.addEventListener('input', updateAndRedraw);
  // Door Settings
  numSectorsInput.addEventListener('input', updateAndRedraw);
  blackAngleInput.addEventListener('input', updateAndRedraw);
  spaceAngleInput.addEventListener('input', updateAndRedraw);


  // --- Initial Setup ---
  updateAndRedraw(); // Calculate initial dimensions/settings and draw
  canvas.style.cursor = 'grab';

</script>

</body>
</html>
