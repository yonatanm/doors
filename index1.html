<!DOCTYPE html>
<html>
<head>
<title>Canvas Door</title>
<style>
  body { margin: 0; overflow: hidden; background-color: #f0f0f0; font-family: sans-serif;}
  canvas { border: 1px solid black; display: block; margin-top: 10px;}
  .controls { padding: 10px; background-color: #eee; border: 1px solid #ccc; margin-bottom: 10px; }
  .controls legend { font-weight: bold; margin-bottom: 5px; }
  .controls div { margin-bottom: 5px; }
  .controls label { display: inline-block; min-width: 150px; margin-right: 5px;}
  .controls input { width: 60px; margin-right: 5px;}
</style>
</head>
<body>

<fieldset class="controls">
  <legend>Global Settings</legend>
  <div>
    <label for="innerWidthInput">Inner Width (cm):</label>
    <input type="number" id="innerWidthInput" value="40" min="10" max="100" step="1">
    <span id="innerWidthValue">40</span> cm
  </div>
  <div>
    <label for="innerHeightInput">Inner Height (cm):</label>
    <input type="number" id="innerHeightInput" value="20" min="10" max="60" step="1">
    <span id="innerHeightValue">20</span> cm
  </div>
    <div>
    <label for="vpOffsetInput">VP Offset Y (cm):</label>
    <input type="number" id="vpOffsetInput" value="5" min="0" max="20" step="1">
    <span id="vpOffsetValue">5</span> cm
  </div>
</fieldset>

<canvas id="doorCanvas" width="800" height="400"></canvas>

<script>
  const canvas = document.getElementById('doorCanvas');
  const ctx = canvas.getContext('2d');

  // Get control elements
  const innerWidthInput = document.getElementById('innerWidthInput');
  const innerHeightInput = document.getElementById('innerHeightInput');
  const vpOffsetInput = document.getElementById('vpOffsetInput');
  const innerWidthValueSpan = document.getElementById('innerWidthValue');
  const innerHeightValueSpan = document.getElementById('innerHeightValue');
  const vpOffsetValueSpan = document.getElementById('vpOffsetValue');


  // --- Draw Flower --- (Fixed position)
  function drawFlower(x, y) {
    // Center (yellow)
    ctx.fillStyle = 'yellow';
    ctx.beginPath();
    ctx.arc(x, y, 15, 0, Math.PI * 2);
    ctx.fill();

    // Petals (red)
    ctx.fillStyle = 'red';
    const petalLength = 30;
    const petalWidth = 10;
    for (let i = 0; i < 6; i++) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate((Math.PI / 3) * i);
      ctx.beginPath();
      ctx.ellipse(0, -petalLength / 2 - 10, petalWidth, petalLength, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  const flowerX = canvas.width / 2; // Centered flower
  const flowerY = canvas.height / 2;

  // --- Door Properties (Constants and Dynamic State) ---
  const scale = 5; // 5 pixels per cm
  const borderWidthCm = 2;
  const borderWidthPx = borderWidthCm * scale; // 10px
  const vpRadiusCm = 1;
  const vpRadiusPx = vpRadiusCm * scale; // 5px

  // State variables that will be updated from controls
  let innerWidthCm = 40;
  let innerHeightCm = 20;
  let vpOffsetYCm = 5;

  // Calculated dimensions (will be updated in updateDimensions)
  let doorWidthCm, doorHeightCm, doorWidthPx, doorHeightPx, vpOffsetYPx;

  // --- Door Drag State ---
  let doorX; // Initial position calculated in updateDimensions
  let doorY; // Position calculated in updateDimensions
  let isDragging = false;
  let dragOffsetX = 0;

  // --- Update Dimensions from Inputs ---
  function updateDimensionsFromInputs() {
    // Read values from inputs
    innerWidthCm = parseFloat(innerWidthInput.value);
    innerHeightCm = parseFloat(innerHeightInput.value);
    vpOffsetYCm = parseFloat(vpOffsetInput.value);

    // Update display spans
    innerWidthValueSpan.textContent = innerWidthCm;
    innerHeightValueSpan.textContent = innerHeightCm;
    vpOffsetValueSpan.textContent = vpOffsetYCm;

    // Recalculate total door dimensions based on inner dimensions + border
    doorWidthCm = innerWidthCm + (borderWidthCm * 2);
    doorHeightCm = innerHeightCm + (borderWidthCm * 2);

    // Recalculate pixel values
    doorWidthPx = doorWidthCm * scale;
    doorHeightPx = doorHeightCm * scale;
    vpOffsetYPx = vpOffsetYCm * scale;

    // Recalculate door's centered position (needed if dimensions change)
    // Don't change doorX if dragging, only recalculate Y and initial X
    if (!isDragging) {
        doorX = (canvas.width - doorWidthPx) / 2;
    }
    doorY = (canvas.height - doorHeightPx) / 2;

    // Keep door within bounds if dimensions change drastically
    doorX = Math.max(0, doorX);
    doorX = Math.min(canvas.width - doorWidthPx, doorX);

    redraw(); // Redraw with new dimensions
  }


  // --- Draw Door and VP ---
  function drawDoor(x, y) {
    // --- Calculations ---
    const innerWidthPx = innerWidthCm * scale;
    const innerHeightPx = innerHeightCm * scale;
    // Inner rectangle top-left corner
    const innerRectX = x + borderWidthPx;
    const innerRectY = y + borderWidthPx;
    // VP center coordinates
    const vpCenterX = x + doorWidthPx / 2;
    const vpCenterY = y + doorHeightPx + vpOffsetYPx;
    const radiusPx = 37 * scale;
    const blackDeg = 3;
    const transDeg = 2;
    const blackRad = blackDeg * Math.PI / 180;
    const stepRad = (blackDeg + transDeg) * Math.PI / 180;

    // --- Drawing ---

    // 1. Draw the border (using total dimensions)
    ctx.strokeStyle = 'black';
    ctx.lineWidth = borderWidthPx;
    ctx.strokeRect(
      x + borderWidthPx / 2,
      y + borderWidthPx / 2,
      doorWidthPx - borderWidthPx, // This is actually innerWidthPx
      doorHeightPx - borderWidthPx  // This is actually innerHeightPx
    );

    // 2. Draw Sectors inside the inner bounds
    ctx.save(); // Save context before clipping

    // Set clipping path to inner rectangle
    ctx.beginPath();
    ctx.rect(innerRectX, innerRectY, innerWidthPx, innerHeightPx);
    ctx.clip();

    // Calculate angles from VP to top-inner corners
    // atan2(y, x) -> angle from positive x-axis, counter-clockwise
    const angleLeft = Math.atan2(innerRectY - vpCenterY, innerRectX - vpCenterX);
    const angleRight = Math.atan2(innerRectY - vpCenterY, (innerRectX + innerWidthPx) - vpCenterX);

    // Draw the sectors
    ctx.fillStyle = 'black';
    let currentStartAngle = angleLeft;
    while (currentStartAngle < angleRight) {
        let currentEndAngle = currentStartAngle + blackRad;
        // Don't let the final sector overshoot the calculated right angle
        if (currentEndAngle > angleRight) {
            currentEndAngle = angleRight;
        }

        if (currentEndAngle > currentStartAngle) { // Ensure angle has width
            ctx.beginPath();
            ctx.moveTo(vpCenterX, vpCenterY);
            // arc(x, y, radius, startAngle, endAngle, anticlockwise)
            ctx.arc(vpCenterX, vpCenterY, radiusPx, currentStartAngle, currentEndAngle);
            ctx.closePath();
            ctx.fill();
        }

        // Move to the start of the next black sector
        currentStartAngle += stepRad;
    }

    ctx.restore(); // Restore context to remove clipping

    // 3. Draw the VP circle (after restoring context)
    ctx.fillStyle = 'blue';
    ctx.beginPath();
    ctx.arc(vpCenterX, vpCenterY, vpRadiusPx, 0, Math.PI * 2);
    ctx.fill();
  }

  // --- Redraw Canvas ---
  function redraw() {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw flower
    drawFlower(flowerX, flowerY);

    // Draw door (at current position x, y using current dimensions)
    drawDoor(doorX, doorY);
  }

  // --- Mouse Event Handlers ---
  canvas.addEventListener('mousedown', (e) => {
    const mouseX = e.offsetX;
    const mouseY = e.offsetY;

    // Check if click is within the door bounds (using current dimensions)
    if (mouseX >= doorX && mouseX <= doorX + doorWidthPx &&
        mouseY >= doorY && mouseY <= doorY + doorHeightPx) {
      isDragging = true;
      dragOffsetX = mouseX - doorX;
      canvas.style.cursor = 'grabbing'; // Change cursor while dragging
    }
  });

  canvas.addEventListener('mousemove', (e) => {
    if (!isDragging) return;

    const mouseX = e.offsetX;
    let newDoorX = mouseX - dragOffsetX;
    // Ensure door stays within canvas bounds (using current width)
    newDoorX = Math.max(0, newDoorX);
    newDoorX = Math.min(canvas.width - doorWidthPx, newDoorX);
    doorX = newDoorX;

    redraw();
  });

  // Combined mouseup and mouseleave logic
  const stopDragging = () => {
     if (isDragging) {
       isDragging = false;
       canvas.style.cursor = 'grab'; // Restore cursor
       // Recalculate door center X if needed after drag finishes and dimensions changed
       // updateDimensionsFromInputs(); // Call this to potentially recenter if needed? Or just redraw? Let's just redraw.
       redraw();
    }
  };

  canvas.addEventListener('mouseup', stopDragging);
  canvas.addEventListener('mouseleave', stopDragging);

  // --- Input Event Listeners ---
  innerWidthInput.addEventListener('input', updateDimensionsFromInputs);
  innerHeightInput.addEventListener('input', updateDimensionsFromInputs);
  vpOffsetInput.addEventListener('input', updateDimensionsFromInputs);

  // --- Initial Setup ---
  updateDimensionsFromInputs(); // Calculate initial dimensions and draw
  canvas.style.cursor = 'grab'; // Set initial cursor


</script>

</body>
</html>
