<!DOCTYPE html>
<html>
<head>
<title>Canvas Door</title>
<style>
  body { margin: 0; overflow: hidden; background-color: #f0f0f0; font-family: sans-serif;}
  canvas { border: 1px solid black; display: block; margin-top: 10px;}
  .controls { padding: 10px; background-color: #eee; border: 1px solid #ccc; margin-bottom: 10px; }
  .controls legend { font-weight: bold; margin-bottom: 5px; }
  .controls div { margin-bottom: 5px; }
  .controls label { display: inline-block; min-width: 150px; margin-right: 5px; text-align: right; }
  .controls input { width: 60px; margin-right: 5px;}
  .controls span { display: inline-block; min-width: 25px; text-align: right;}
</style>
</head>
<body>

<fieldset class="controls">
  <legend>Global Settings</legend>
  <div>
    <label for="innerWidthInput">Inner Width (cm):</label>
    <input type="number" id="innerWidthInput" value="40" min="10" max="100" step="1">
    <span id="innerWidthValue">40</span> cm
  </div>
  <div>
    <label for="innerHeightInput">Inner Height (cm):</label>
    <input type="number" id="innerHeightInput" value="20" min="10" max="60" step="1">
    <span id="innerHeightValue">20</span> cm
  </div>
    <div>
    <label for="vpOffsetInput">VP Offset Y (cm):</label>
    <input type="number" id="vpOffsetInput" value="5" min="0" max="20" step="1">
    <span id="vpOffsetValue">5</span> cm
  </div>
</fieldset>

<fieldset class="controls">
    <legend>Door Settings</legend>
    <div>
        <label for="numSectorsInput">Num Black Sectors:</label>
        <input type="number" id="numSectorsInput" value="19" min="1" max="50" step="2"> <!-- Step 2 to keep it odd? Or allow even? Let's allow any for now -->
        <span id="numSectorsValue">19</span>
    </div>
    <div>
        <label for="blackAngleInput">Black Sector Angle:</label>
        <input type="number" id="blackAngleInput" value="3" min="0.1" max="45" step="0.1">
        <span id="blackAngleValue">3</span> deg
    </div>
    <div>
        <label for="spaceAngleInput">Space Angle:</label>
        <input type="number" id="spaceAngleInput" value="2" min="0" max="45" step="0.1">
        <span id="spaceAngleValue">2</span> deg
    </div>
</fieldset>

<canvas id="doorCanvas" width="800" height="400"></canvas>

<script>
  const canvas = document.getElementById('doorCanvas');
  const ctx = canvas.getContext('2d');

  // Get Global control elements
  const innerWidthInput = document.getElementById('innerWidthInput');
  const innerHeightInput = document.getElementById('innerHeightInput');
  const vpOffsetInput = document.getElementById('vpOffsetInput');
  const innerWidthValueSpan = document.getElementById('innerWidthValue');
  const innerHeightValueSpan = document.getElementById('innerHeightValue');
  const vpOffsetValueSpan = document.getElementById('vpOffsetValue');

  // Get Door Setting control elements
  const numSectorsInput = document.getElementById('numSectorsInput');
  const blackAngleInput = document.getElementById('blackAngleInput');
  const spaceAngleInput = document.getElementById('spaceAngleInput');
  const numSectorsValueSpan = document.getElementById('numSectorsValue');
  const blackAngleValueSpan = document.getElementById('blackAngleValue');
  const spaceAngleValueSpan = document.getElementById('spaceAngleValue');


  // --- Draw Flower --- (Fixed position)
  function drawFlower(x, y) {
    // Center (yellow)
    ctx.fillStyle = 'yellow';
    ctx.beginPath();
    ctx.arc(x, y, 15, 0, Math.PI * 2);
    ctx.fill();

    // Petals (red)
    ctx.fillStyle = 'red';
    const petalLength = 30;
    const petalWidth = 10;
    for (let i = 0; i < 6; i++) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate((Math.PI / 3) * i);
      ctx.beginPath();
      ctx.ellipse(0, -petalLength / 2 - 10, petalWidth, petalLength, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  const flowerX = canvas.width / 2; // Centered flower
  const flowerY = canvas.height / 2;

  // --- Door Properties (Constants and Dynamic State) ---
  const scale = 5; // 5 pixels per cm
  const borderWidthCm = 2;
  const borderWidthPx = borderWidthCm * scale; // 10px
  const vpRadiusCm = 1;
  const vpRadiusPx = vpRadiusCm * scale; // 5px
  const sectorRadiusCm = 37;
  const sectorRadiusPx = sectorRadiusCm * scale;

  // State variables - Global
  let innerWidthCm = 40;
  let innerHeightCm = 20;
  let vpOffsetYCm = 5;

  // State variables - Door Settings
  let numBlackSectors = 19;
  let blackSectorDeg = 3;
  let spaceSectorDeg = 2;

  // Calculated dimensions (will be updated in updateAndRedraw)
  let doorWidthCm, doorHeightCm, doorWidthPx, doorHeightPx, vpOffsetYPx;
  let blackSectorRad, spaceSectorRad;

  // --- Door Drag State ---
  let doorX; // Initial position calculated in updateAndRedraw
  let doorY; // Position calculated in updateAndRedraw
  let isDragging = false;
  let dragOffsetX = 0;

  // --- Update State from Inputs & Redraw ---
  function updateAndRedraw() {
    // Read global values from inputs
    innerWidthCm = parseFloat(innerWidthInput.value);
    innerHeightCm = parseFloat(innerHeightInput.value);
    vpOffsetYCm = parseFloat(vpOffsetInput.value);

    // Read door settings values from inputs
    numBlackSectors = parseInt(numSectorsInput.value);
    blackSectorDeg = parseFloat(blackAngleInput.value);
    spaceSectorDeg = parseFloat(spaceAngleInput.value);

    // Update display spans
    innerWidthValueSpan.textContent = innerWidthCm;
    innerHeightValueSpan.textContent = innerHeightCm;
    vpOffsetValueSpan.textContent = vpOffsetYCm;
    numSectorsValueSpan.textContent = numBlackSectors;
    blackAngleValueSpan.textContent = blackSectorDeg.toFixed(1);
    spaceAngleValueSpan.textContent = spaceSectorDeg.toFixed(1);


    // Recalculate total door dimensions based on inner dimensions + border
    doorWidthCm = innerWidthCm + (borderWidthCm * 2);
    doorHeightCm = innerHeightCm + (borderWidthCm * 2);

    // Recalculate pixel values
    doorWidthPx = doorWidthCm * scale;
    doorHeightPx = doorHeightCm * scale;
    vpOffsetYPx = vpOffsetYCm * scale;
    blackSectorRad = blackSectorDeg * Math.PI / 180;
    spaceSectorRad = spaceSectorDeg * Math.PI / 180;

    // Recalculate door's centered position (needed if dimensions change)
    // Don't change doorX if dragging, only recalculate Y and initial X
    if (!isDragging) {
        doorX = (canvas.width - doorWidthPx) / 2;
    }
    doorY = (canvas.height - doorHeightPx) / 2;

    // Keep door within bounds if dimensions change drastically
    doorX = Math.max(0, doorX);
    doorX = Math.min(canvas.width - doorWidthPx, doorX);

    redraw(); // Redraw with new dimensions/settings
  }


  // --- Draw Door and VP ---
  function drawDoor(x, y) {
    // --- Calculations ---
    const innerWidthPx = innerWidthCm * scale;
    const innerHeightPx = innerHeightCm * scale;
    const innerRectX = x + borderWidthPx;
    const innerRectY = y + borderWidthPx;
    const vpCenterX = x + doorWidthPx / 2;
    const vpCenterY = y + doorHeightPx + vpOffsetYPx;

    // --- Drawing ---

    // 1. Draw the border
    ctx.strokeStyle = 'black';
    ctx.lineWidth = borderWidthPx;
    ctx.strokeRect(
      x + borderWidthPx / 2,
      y + borderWidthPx / 2,
      innerWidthPx, // Use inner directly
      innerHeightPx // Use inner directly
    );

    // 2. Draw Sectors inside the inner bounds
    ctx.save(); // Save context before clipping

    // Set clipping path to inner rectangle
    ctx.beginPath();
    ctx.rect(innerRectX, innerRectY, innerWidthPx, innerHeightPx);
    ctx.clip();

    // Calculate total angle span and starting angle for centering
    const numSpaces = Math.max(0, numBlackSectors - 1);
    const totalAngleRad = (numBlackSectors * blackSectorRad) + (numSpaces * spaceSectorRad);
    // Center the fan horizontally around the vertical axis (-PI/2 or 270 degrees)
    const startAngle = (-Math.PI / 2) - (totalAngleRad / 2);
    const stepRad = blackSectorRad + spaceSectorRad;

    // Draw the sectors
    ctx.fillStyle = 'black';
    let currentAngle = startAngle;
    for (let i = 0; i < numBlackSectors; i++) {
        const endAngle = currentAngle + blackSectorRad;

        if (blackSectorRad > 0) { // Only draw if angle > 0
             ctx.beginPath();
             ctx.moveTo(vpCenterX, vpCenterY);
             ctx.arc(vpCenterX, vpCenterY, sectorRadiusPx, currentAngle, endAngle);
             ctx.closePath();
             ctx.fill();
        }

        // Move to the start of the next black sector
        currentAngle += stepRad;
    }

    ctx.restore(); // Restore context to remove clipping

    // 3. Draw the VP circle (after restoring context)
    ctx.fillStyle = 'blue';
    ctx.beginPath();
    ctx.arc(vpCenterX, vpCenterY, vpRadiusPx, 0, Math.PI * 2);
    ctx.fill();
  }

  // --- Redraw Canvas ---
  function redraw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawFlower(flowerX, flowerY);
    drawDoor(doorX, doorY);
  }

  // --- Mouse Event Handlers ---
  canvas.addEventListener('mousedown', (e) => {
    const mouseX = e.offsetX;
    const mouseY = e.offsetY;
    if (mouseX >= doorX && mouseX <= doorX + doorWidthPx &&
        mouseY >= doorY && mouseY <= doorY + doorHeightPx) {
      isDragging = true;
      dragOffsetX = mouseX - doorX;
      canvas.style.cursor = 'grabbing';
    }
  });

  canvas.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    const mouseX = e.offsetX;
    let newDoorX = mouseX - dragOffsetX;
    newDoorX = Math.max(0, newDoorX);
    newDoorX = Math.min(canvas.width - doorWidthPx, newDoorX);
    doorX = newDoorX;
    redraw();
  });

  const stopDragging = () => {
     if (isDragging) {
       isDragging = false;
       canvas.style.cursor = 'grab';
       redraw();
    }
  };
  canvas.addEventListener('mouseup', stopDragging);
  canvas.addEventListener('mouseleave', stopDragging);

  // --- Input Event Listeners ---
  // Global
  innerWidthInput.addEventListener('input', updateAndRedraw);
  innerHeightInput.addEventListener('input', updateAndRedraw);
  vpOffsetInput.addEventListener('input', updateAndRedraw);
  // Door Settings
  numSectorsInput.addEventListener('input', updateAndRedraw);
  blackAngleInput.addEventListener('input', updateAndRedraw);
  spaceAngleInput.addEventListener('input', updateAndRedraw);


  // --- Initial Setup ---
  updateAndRedraw(); // Calculate initial dimensions/settings and draw
  canvas.style.cursor = 'grab';

</script>

</body>
</html>
